---
layout:     post
title:      http协议原理
subtitle:   http协议原理学习记录心得总结
date:       2018-3-9 17:33:02
author:     gankai
header-img: img/vue.jpg
catalog: true
tags:
    - http
    - tcp
    - udp
---

# http协议原理

## 2018年3月9日00:24:49  001

<h1>http的三次握手是什么意思,为什么要有三次握手?</h1>
**答:**

  `为了防止服务端开启一些无用的链接,因为网络传送是有延时的,服务器开销的问题.中间可能隔了很长的距离(比如光纤,或者说各种代理服务器),在传送过程中,第一次握手,客户端发送一次创建链接的请求数据比如:`SYN = 1, Seq = X`,服务端接收到请求,创建链接,将数据(SYN = 1,ACK = X+1, Seq = Y)返回给客户端,但是,在这个传送过程中,数据可能会丢失,服务端不知道客户端是否接收到了数据,然后服务端就会将端口一直开着等待客户端的第三次握手,也就是说服务端会等待一段时间,如果一段时间之后,没有进行第三次握手,服务端就会将端口关掉,如果客户端没有接到服务端的第二次握手,就不会再次请求;`

  `weshak抓包工具`

  URL: 统一资源定位器;

  URI: 统一资源定位符;

  URN: 永久资源定位符(在资源移动之后, 还能被找到,目前还没有非常成熟的使用方案);

<h4>curl的使用</h4>

  在git bash 中 `crul baidu.com`查看,或者,crul -v www.baidu.com 看请求的所有报文的详细信息:
请求的:
      Trying 180.97.33.108...
    * TCP_NODELAY set
    * Connected to www.baidu.com (180.97.33.108) port 80 (#0)
    > GET / HTTP/1.1
    > Host: www.baidu.com
    > User-Agent: curl/7.63.0
    > Accept: */*
    >
返回的:

    < HTTP/1.1 200 OK
    < Accept-Ranges: bytes
    < Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
    < Connection: Keep-Alive
    < Content-Length: 2381
    < Content-Type: text/html
    < Date: Sat, 09 Mar 2019 11:17:45 GMT
    < Etag: "588604f8-94d"
    < Last-Modified: Mon, 23 Jan 2017 13:28:24 GMT
    < Pragma: no-cache
    < Server: bfe/1.0.8.18
    < Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/
    <


<h3>浏览器缓存相关 Cache-Control  客户端缓存的可缓存性</h3>

`public` 任何地方都能缓存,

`private`指定地方能缓存

`no-cache`没有缓存(你可以在本地进行缓存,不过需要经过服务器的验证同意)

`no-store` 永远都不用缓存,只能每次都去服务器上获取新的数据,只要使用了这个任何有关缓存的都会失效,权重很高;

`no-transform`告诉代理服务器不能随便进行压缩转换,改变内容;

`max-age=<seconds>` 缓存到期时间(秒为单位)

`s-maxage=<seconds>`只有设置带来的时候,才会走这个,缓存到期时间,这是专门为代理服务器设置的

`must-revalidate` 重新验证 `proxy-revalidate`缓存服务器中

以上头消息,非约束性的,可以按照这个规范去做,

    response.writeHead(200, {
         'Content-Type': 'text/javascript',
         'Cache-Control':'max-age=20,public'  // 开启缓存
     })
     response.end("console.log('script.js')")

***这也就是为什么前端请求数据的时候,url上会加上一串哈希码,为的是清空浏览器的缓存.***

<h3> `Last-Modified` 上次修改时间</h3>

    配合If-Modified-Since或者If-Unmodified-Since使用 对比上次修改时间以验证资源是否更新

    代码:response.writeHead(200, {
            'Content-Type': 'text/javascript',
            'Cache-Control':'max-age=200000000,no-cache',  //是否开启缓存
            'Last-Modified':'123',
            'Etag':'777'
        })
    Response Header:
        Cache-Control: max-age=200000000,no-cache  //哪怕设置了no-chche也会访问后台数据
        Connection: keep-alive
        Content-Type: text/javascript
        Date: Sun, 10 Mar 2019 12:33:54 GMT
        Etag: 777                                    // 第一次发送请求
        Last-Modified: 123                           // 第一次发送请求
        Transfer-Encoding: chunked

    Request Headers:
        GET /script.js HTTP/1.1
        Host: localhost:8888
        Connection: keep-alive
        If-None-Match: 777              // 配合 Etag 第一次发送请求带上的
        If-Modified-Since: 123          // 配合 Last-Modified
        User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36
        Accept: */*
        Referer: http://localhost:8888/
        Accept-Encoding: gzip, deflate, br
        Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
        Cookie: _ga=GA1.1.1520046618.1549612093; Hm_lvt_b50bf2b12b5338a1845e33832976fd68=1549789561


`Etag` 数据签名  

    配合  If-Match 或者 If-Non-Match 使用,对比资源的签名判断是否使用缓存

    const Etag = request.headers['if-none-match']
           if (Etag === '777') {
               response.writeHead(304, {
                   'Content-Type': 'text/javascript',
                   'Cache-Control': 'max-age=200000000,no-cache', //是否开启缓存
                   'Last-Modified': '123',
                   'Etag': '777'
               })
               response.end("")
    // 这个时候,服务器返回的是空,但是显示的却是上次缓存的数据 `console.log('script.js')`
    修改返回的数据为 response.end("11111"),但是网页返回的还是`console.log('script.js')`
`type:为Not Modified 意思是未从后台获取数据,直接从浏览器获取数据;
304code的作用是告诉浏览器资源没有被修改,在请求数据的时候,可以直接从缓存body中读取,无需从后台获取.`
<h3>Cookie</h3>

通过设置`Set-CooKie`设置,下次请求会自动带上,键值对的形式可以设置多个.

***属性***

通过设置`max-age`和`expires`设置过期时间,`Secure`只在https的时候发送,如果设置了`HttpOnly`就无法通过document.cooKie访问,这样就可以防止`csrf`攻击,原理就是在用户的浏览器js脚本中放置一种链接.引导用户将自己的cookie发送的攻击者指定的网站,从而攻击者就可以获取用户所有的数据资料,冒充用户进行违法操作;


    response.writeHead(200, {
         'Content-Type': 'text/html',
         'Set-Cookie': ['id=123;max-age=3', 'abc=456;HttpOnly']
         // 设置第一个cookie的超时为2s,第二个cookie的属性为HttpOnly,不允许js访问这个cookie;
       })

------------------

 不过，说 HTTP/1.1 是“小幅度修正”也不太确切，它还是有很多实质性进步的。毕竟经过了多年的实战检验，比起 0.9/1.0 少了“学术气”，更加“接地气”，同时表述也更加严谨。HTTP/1.1 主要的变更点有：

<ol>
<li>增加了 PUT、DELETE 等新的方法；</li>
<li>增加了缓存管理和控制；</li>
<li>明确了连接管理，允许持久连接；</li>
<li>允许响应数据分块（chunked），利于传输大文件；</li>
<li>强制要求 Host 头，让互联网主机托管成为可能。</li>
</ol>

HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：

<ol>
<li>二进制协议，不再是纯文本；</li>
<li>可发起多个请求，废弃了 1.1 里的管道；</li>
<li>使用专用算法压缩头部，减少数据传输量；</li>
<li>允许服务器主动向客户端推送数据；</li>
<li>增强了安全性，“事实上”要求加密通信。</li>
</ol>

*问*

<ul>
<li>你是怎么理解 HTTP 字面上的“超文本”和“传输协议”的？</li>
<li>能否谈一下你对 HTTP 的认识？越多越好。</li>
<li>HTTP 有什么特点？有什么优点和缺点？</li>
<li>HTTP 下层都有哪些协议？是如何工作的？</li>
<li>……</li>
</ul>

<span class="orange">HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</span>

<p><strong>HTTP 不是一个孤立的协议</strong>。</p>

<p>在互联网世界里，HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。</p>

<img src="https://static001.geekbang.org/resource/image/27/cc/2781919e73f5d258ff1dc371af632acc.png" alt="">

<b>指出一点误解：两个浏览器不能通信。服务器可以当客户端，但浏览器只是客户端。</b>

<p>上网就要用到浏览器，常见的浏览器有 Google 的 Chrome、Mozilla 的 Firefox、Apple 的 Safari、Microsoft 的 IE 和 Edge，还有小众的 Opera 以及国内的各种“换壳”的“极速”“安全”浏览器。</p>

<p><img src="https://static001.geekbang.org/resource/image/61/8b/613fffb6defee1735431dc5f89085d8b.png" alt="unpreview"></p>

<p><strong>CDN</strong>，全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。</p>
<p>CDN 有什么好处呢？</p>
<p>简单来说，它可以缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接在“半路”就可以获取响应。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。</p>

<p>CDN 也是现在互联网中的一项重要基础设施，除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分，我也会在后面用一讲的篇幅来专门讲解 CDN。</p>

<p><strong>TCP 协议</strong>是“<strong><span class="orange">T</span></strong>ransmission <strong><span class="orange">C</span></strong>ontrol <strong><span class="orange">P</span></strong>rotocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供<span class="orange">可靠的、字节流</span>形式的通信，是 HTTP 协议得以实现的基础。</p>

<p>“可靠”是指保证数据不丢失，“字节流”是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。</p>

<p><img src="https://static001.geekbang.org/resource/image/2b/03/2b8fee82b58cc8da88c74a33f2146703.png" alt=""></p>

<p>TCP/IP 协议总共有四层，就像搭积木一样，每一层需要下层的支撑，同时又支撑着上层，任何一层被抽掉都可能会导致整个协议栈坍塌。</p>
<p>第一层叫“<strong>链接层</strong>”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。</p>
<p>第二层叫“<strong>网际层</strong>”或者“<strong>网络互连层</strong>”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。</p>
<p>第三层叫“<strong>传输层</strong>”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。</p>
<p>协议栈的第四层叫“<strong>应用层</strong>”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。</p>

<p>MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>

<h2>OSI 网络分层模型</h2>
<p>看完 TCP/IP 协议栈，你可能要问了，“它只有四层，那常说的七层怎么没见到呢？”</p>
<p>别着急，这就是今天要说的第二个网络分层模型：<strong>OSI</strong>，全称是“<strong>开放式系统互联通信参考模型</strong>”（Open System Interconnection Reference Model）。</p>

<p>OSI 模型分成了七层，部分层次与 TCP/IP 很像，从下到上分别是：</p>

<p><img src="https://static001.geekbang.org/resource/image/3a/dc/3abcf1462621ff86758a8d9571c07cdc.png" alt=""></p>

<ol>
<li>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；</li>
<li>第二层：数据链路层，它基本相当于 TCP/IP 的链接层；</li>
<li>第三层：网络层，相当于 TCP/IP 里的网际层；</li>
<li>第四层：传输层，相当于 TCP/IP 里的传输层；</li>
<li>第五层：会话层，维护网络中的连接状态，即保持会话和同步；</li>
<li>第六层：表示层，把数据转换为合适、可理解的语法和语义；</li>
<li>第七层：应用层，面向具体的应用传输数据。</li>
</ol>

<h2>两个分层模型的映射关系</h2>

<p><img src="https://static001.geekbang.org/resource/image/9d/94/9d9b3c9274465c94e223676b6d434194.png" alt=""></p>

<ol>
<li>第一层：物理层，TCP/IP 里无对应；</li>
<li>第二层：数据链路层，对应 TCP/IP 的链接层；</li>
<li>第三层：网络层，对应 TCP/IP 的网际层；</li>
<li>第四层：传输层，对应 TCP/IP 的传输层；</li>
<li>第五、六、七层：统一对应到 TCP/IP 的应用层。</li>
</ol>

<h2>域名的解析</h2>

<p>DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：</p>

<ol>
<li>根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；</li>
<li>顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；</li>
<li>权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。</li>
</ol>

<p><img src="https://static001.geekbang.org/resource/image/6b/f2/6b020454987543efdd1cf6ddec784bf2.png" alt=""></p>

<p>例如，你要访问“www.apple.com”，就要进行下面的三次查询：</p>

<ol>
<li>访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；</li>
<li>访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；</li>
<li>最后访问“apple.com”域名服务器，就得到了“www.apple.com”的地址。</li>
</ol>

<p>虽然核心的 DNS 系统遍布全球，服务能力很强也很稳定，但如果全世界的网民都往这个系统里挤，即使不挤瘫痪了，访问速度也会很慢。</p>

<p>所以在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“<strong>缓存</strong>”。</p>

<p>首先，许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。</p>

<p>下面的这张图比较完整地表示了现在的 DNS 架构。</p>

<p><img src="https://static001.geekbang.org/resource/image/e5/ac/e51df3245609880641043af65bba94ac.png" alt=""></p>

<p>在 Nginx 里有这么一条配置指令“resolver”，它就是用来配置 DNS 服务器的，如果没有它，那么 Nginx 就无法查询域名对应的 IP，也就无法反向代理到外部的网站。</p>

<b>对于DNS解析的过程：浏览器DNS缓存->操作系统缓存->Hosts文件->非权威域名服务器->根域名服务器->顶级域名服务器->权威域名服务器</b>

<h2 class="cZCVMzBP_0">08 | 键入网址再按下回车，后面究竟发生了什么？</h2>

<p><img src="https://static001.geekbang.org/resource/image/8a/19/8a5bddd3d8046daf7032c7d60a3d1a19.png" alt=""></p>

<p>再简要叙述一下这次最简单的浏览器 HTTP 请求过程：</p>

<ol>
<li>浏览器从地址栏的输入中获得服务器的 IP 地址和端口号；</li>
<li>浏览器用 TCP 的三次握手与服务器建立连接；</li>
<li>浏览器向服务器发送拼好的报文；</li>
<li>服务器收到报文后处理请求，同样拼好报文再发给浏览器；</li>
<li>浏览器解析报文，渲染输出页面。</li>
</ol>

<h1 class="cZCVMzBP_0">09 | HTTP报文是什么样子的？</h1>

<h2>报文结构</h2>

<p>你也许对 TCP/UDP 的报文格式有所了解，拿 TCP 报文来举例，它在实际要传输的数据之前附加了一个 20 字节的头部数据，存储 TCP 协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等等。</p>

<p><img src="https://static001.geekbang.org/resource/image/17/95/174bb72bad50127ac84427a72327f095.png" alt=""></p>

<p>HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p>

<ol>
<li>起始行（start line）：描述请求或响应的基本信息；</li>
<li>头部字段集合（header）：使用 key-value 形式更详细地说明报文；</li>
<li>消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li>
</ol>

<p>这其中前两部分起始行和头部字段经常又合称为“<strong>请求头</strong>”或“<strong>响应头</strong>”，消息正文又称为“<strong>实体</strong>”，但与“<strong>header</strong>”对应，很多时候就直接称为“<strong>body</strong>”。</p>

<p>HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。</p>

<p>所以，一个完整的 HTTP 报文就像是下图的这个样子，注意在 header 和 body 之间有一个“空行”。</p>

<p><img src="https://static001.geekbang.org/resource/image/62/3c/62e061618977565c22c2cf09930e1d3c.png" alt=""></p>

<h2>请求行</h2>

<p>了解了 HTTP 报文的基本结构后，我们来看看请求报文里的起始行也就是<strong>请求行</strong>（request line），它简要地描述了<strong>客户端想要如何操作服务器端的资源</strong>。</p>

<p>请求行由三部分构成：</p>

<ol>
<li>请求方法：是一个动词，如 GET/POST，表示对资源的操作；</li>
<li>请求目标：通常是一个 URI，标记了请求方法要操作的资源；</li>
<li>版本号：表示报文使用的 HTTP 协议版本。</li>
</ol>

<p>这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。</p>

<p><img src="https://static001.geekbang.org/resource/image/36/b9/36108959084392065f36dff3e12967b9.png" alt=""></p>

<code class="ps"><table class="hljs-ln"><tbody><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line">GET / HTTP/1.1</div></td></tr><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line"><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></td></tr></tbody></table><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></code>

<p>在这个请求行里，“GET”是请求方法，“/”是请求目标，“HTTP/1.1”是版本号，把这三部分连起来，意思就是“服务器你好，我想获取网站根目录下的默认文件，我用的协议版本号是 1.1，请不要用 1.0 或者 2.0 回复我。”</p>

<h2>状态行</h2>

<p>看完了请求行，我们再看响应报文里的起始行，在这里它不叫“响应行”，而是叫“<strong>状态行</strong>”（status line），意思是<strong>服务器响应的状态</strong>。</p>

<p>比起请求行来说，状态行要简单一些，同样也是由三部分构成：</p>

<ol>
<li>版本号：表示报文使用的 HTTP 协议版本；</li>
<li>状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；</li>
<li>原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。</li>
</ol>

<p><img src="https://static001.geekbang.org/resource/image/a1/00/a1477b903cd4d5a69686683c0dbc3300.png" alt=""></p>

<code class="ps"><table class="hljs-ln"><tbody><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line">HTTP/1.1 200 OK</div></td></tr><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line"><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></td></tr></tbody></table><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></code>

<p>意思就是：“浏览器你好，我已经处理完了你的请求，这个报文使用的协议版本号是 1.1，状态码是 200，一切 OK。”</p>

<h2>头部字段</h2>

<p>请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头，我画了两个示意图，你可以看一下。</p>

<p><img src="https://static001.geekbang.org/resource/image/1f/ea/1fe4c1121c50abcf571cebd677a8bdea.png" alt=""></p>

<p><img src="https://static001.geekbang.org/resource/image/cb/75/cb0d1d2c56400fe9c9988ee32842b175.png" alt=""></p>

<p>HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。</p>

<p>不过使用头字段需要注意下面几点：</p>

<ol>
<li>字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</li>
<li>字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；</li>
<li>字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</li>
<li>字段的顺序是没有意义的，可以任意排列不影响语义；</li>
<li>字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。</li>
</ol>

<h2>常用头字段</h2>

<p>HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：</p>

<ol>
<li>通用字段：在请求头和响应头里都可以出现；</li>
<li>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；</li>
<li>响应字段：仅能出现在响应头里，补充说明响应报文的信息；</li>
<li>实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。</li>
</ol>

<p>首先要说的是<strong>Host</strong>字段，它属于请求字段，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里要求<strong>必须出现</strong>的字段，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。</p>

<p>Host 字段告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择，有点像是一个简单的“路由重定向”。</p>

<p><strong>User-Agent</strong>是请求字段，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。</p>

<p><strong>Date</strong>字段是一个通用字段，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。</p>

<p><strong>Server</strong>字段是响应字段，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号，例如在我们的实验环境里它就是“Server: openresty/1.15.8.1”，即使用的是 OpenResty 1.15.8.1。</p>

<p>Server 字段也不是必须要出现的，因为这会把服务器的一部分信息暴露给外界，如果这个版本恰好存在 bug，那么黑客就有可能利用 bug 攻陷服务器。所以，有的网站响应头里要么没有这个字段，要么就给出一个完全无关的描述信息。</p>

<p>实体字段里要说的一个是<strong>Content-Length</strong>，它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输。</p>

<h1 class="cZCVMzBP_0">10 | 应该如何理解请求方法？</h1>

<p>目前 HTTP/1.1 规定了八种方法，单词<strong>都必须是大写的形式</strong>，我先简单地列把它们列出来，后面再详细讲解。</p>

<ol>
<li>GET：获取资源，可以理解为读取或者下载数据；</li>
<li>HEAD：获取资源的元信息；</li>
<li>POST：向资源提交数据，相当于写入或上传数据；</li>
<li>PUT：类似 POST；</li>
<li>DELETE：删除资源；</li>
<li>CONNECT：建立特殊的连接隧道；</li>
<li>OPTIONS：列出可对资源实行的方法；</li>
<li>TRACE：追踪请求 - 响应的传输路径。</li>
</ol>

<p><img src="https://static001.geekbang.org/resource/image/3c/6d/3cdc8ac71b80929f4a94dfeb9ffe4b6d.jpg" alt=""></p>

<p>看看这些方法，是不是有点像对文件或数据库的“增删改查”操作，只不过这些动作操作的目标不是本地资源，而是远程服务器上的资源，所以只能由客户端“请求”或者“指示”服务器来完成。</p>
<p>既然请求方法是一个“指示”，那么客户端自然就没有决定权，服务器掌控着所有资源，也就有绝对的决策权力。它收到 HTTP 请求报文后，看到里面的请求方法，可以执行也可以拒绝，或者改变动作的含义，毕竟 HTTP 是一个“协议”，两边都要“商量着来”。</p>

<p>比如，你发起了一个 GET 请求，想获取“/orders”这个文件，但这个文件保密级别比较高，不是谁都能看的，服务器就可以有如下的几种响应方式：</p>

<ol>
<li>假装这个文件不存在，直接返回一个 404 Not found 报文；</li>
<li>稍微友好一点，明确告诉你有这个文件，但不允许访问，返回一个 403 Forbidden；</li>
<li>再宽松一些，返回 405 Method Not Allowed，然后用 Allow 头告诉你可以用 HEAD 方法获取文件的元信息。</li>
</ol>
<p><strong>GET</strong>方法应该是 HTTP 协议里最知名的请求方法了，也应该是用的最多的，自 0.9 版出现并一直被保留至今，是名副其实的“元老”。</p>

<p>它的含义是请求<strong>从服务器获取资源</strong>，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。</p>

<p><strong>HEAD</strong>方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。</p>

<p>HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”。因为它的响应头与 GET 完全相同，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。</p>

<p>GET 和 HEAD 方法是从服务器获取数据，而 POST 和 PUT 方法则是相反操作，向 URI 指定的资源提交数据，数据就放在报文的 body 里。</p>

<p>POST 也是一个经常用到的请求方法，使用频率应该是仅次于 GET，应用的场景也非常多，只要向服务器发送数据，用的大多数都是 POST。</p>

<p><strong>DELETE</strong>方法指示服务器删除资源，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理 DELETE 请求。</p>

<p><strong>CONNECT</strong>是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色。</p>

<p><strong>OPTIONS</strong>方法要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。</p>

<p><strong>TRACE</strong>方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。</p>

<p>虽然 HTTP/1.1 里规定了八种请求方法，但它并没有限制我们只能用这八种方法，这也体现了 HTTP 协议良好的扩展性，我们可以任意添加请求动作，只要请求方和响应方都能理解就行。</p>

<h2>安全与幂等</h2>

<p>关于请求方法还有两个面试时有可能会问到、比较重要的概念：<strong>安全</strong>与<strong>幂等</strong>。</p>

<p>在 HTTP 协议里，所谓的“<strong>安全</strong>”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。</p>

<p>所谓的“<strong>幂等</strong>”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。</p>

<p>很显然，GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。</p>

<p>按照 RFC 里的语义，POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的；而 PUT 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。</p>

<h2>URI 的基本组成</h2>

<p>下面的这张图显示了 URI 最常用的形式，由 scheme、host:port、path 和 query 四个部分组成，但有的部分可以视情况省略。</p>

<p><img src="https://static001.geekbang.org/resource/image/46/2a/46581d7e1058558d8e12c1bf37d30d2a.png" alt=""></p>

<h2>URI 的基本组成</h2>

<p>URI 第一个组成部分叫<strong>scheme</strong>，翻译成中文叫“<strong>方案名</strong>”或者“<strong>协议名</strong>”，表示<strong>资源应该使用哪种协议</strong>来访问。</p>

<p>最常见的当然就是“http”了，表示使用 HTTP 协议。另外还有“https”，表示使用经过加密、安全的 HTTPS 协议。此外还有其他不是很常见的 scheme，例如 ftp、ldap、file、news 等。</p>

<p>浏览器或者你的应用程序看到 URI 里的 scheme，就知道下一步该怎么走了，会调用相应的 HTTP 或者 HTTPS 下层 API。显然，如果一个 URI 没有提供 scheme，即使后面的地址再完善，也是无法处理的。</p>

<p>在 scheme 之后，必须是<strong>三个特定的字符</strong>“<strong>://</strong>”，它把 scheme 和后面的部分分离开。</p>

<p>在“://”之后，是被称为“<strong>authority</strong>”的部分，表示<strong>资源所在的主机名</strong>，通常的形式是“host:port”，即主机名加端口号。</p>

<p>有了协议名和主机地址、端口号，再加上后面<strong>标记资源所在位置</strong>的<strong>path</strong>，浏览器就可以连接服务器访问资源了。</p>

<p>这里我也要再次提醒你注意，URI 的 path 部分必须以“/”开始，也就是必须包含“/”，不要把“/”误认为属于前面 authority。</p>

<p>说了这么多“理论”，来看几个实例。</p>

<code class="ps"><table class="hljs-ln"><tbody><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line">http://nginx.org</div></td></tr><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line">http://www.chrono.com:8080/11-1</div></td></tr><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line">https://tools.ietf.org/html/rfc7230</div></td></tr><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line">file:///D:/http_study/www/</div></td></tr><tr><td class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></td><td class="hljs-ln-code"><div class="hljs-ln-line"><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></td></tr></tbody></table><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></code>

<p>第一个 URI 算是最简单的了，协议名是“http”，主机名是“nginx.org”，端口号省略，所以是默认的 80，而路径部分也被省略了，默认就是一个“/”，表示根目录。</p>

<p>第二个 URI 是在实验环境里这次课程的专用 URI，主机名是“www.chrono.com”，端口号是 8080，后面的路径是“/11-1”。</p>

<p>第三个是 HTTP 协议标准文档 RFC7230 的 URI，主机名是“tools.ietf.org”，路径是“/html/rfc7230”。</p>

<p>最后一个 URI 要注意了，它的协议名不是“http”，而是“file”，表示这是本地文件，而后面居然有三个斜杠，这是怎么回事？</p>

<p>如果你刚才仔细听了 scheme 的介绍就能明白，这三个斜杠里的前两个属于 URI 特殊分隔符“://”，然后后面的“/D:/http_study/www/”是路径，而中间的主机名被“省略”了。这实际上是 file 类型 URI 的“特例”，它允许省略主机名，默认是本机 localhost。</p>

<p>但对于 HTTP 或 HTTPS 这样的网络通信协议，主机名是绝对不能省略的。原因之前也说了，会导致浏览器无法找到服务器。</p>

<h1 class="cZCVMzBP_0">12 | 响应状态码该怎么用？</h1>

<p>响应报文由响应头加响应体数据组成，响应头又由状态行和头字段构成。</p>

<h2>状态码</h2>

<ul>
<li>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</li>
<li>2××：成功，报文已经收到并被正确处理；</li>
<li>3××：重定向，资源位置发生变动，需要客户端重新发送请求；</li>
<li>4××：客户端错误，请求报文有误，服务器无法处理；</li>
<li>5××：服务器错误，服务器在处理请求时内部发生了错误。</li>
</ul>

<p>接下来我就挑一些实际开发中比较有价值的状态码逐个详细介绍。</p>

<h2>1××</h2>

<p>1××类状态码属于提示信息，是协议处理的中间状态，实际能够用到的时候很少。</p>

<p>我们偶尔能够见到的是“<strong>101 Switching Protocols</strong>”。它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。</p>

<h2>2××</h2>

<p>2××类状态码表示服务器收到并成功处理了客户端的请求，这也是客户端最愿意看到的状态码。</p>

<p>“<strong>200 OK</strong>”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据。</p>

<p>“<strong>204 No Content</strong>”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。</p>

<p>“<strong>206 Partial Content</strong>”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。</p>

<p>状态码 206 通常还会伴随着头字段“<strong>Content-Range</strong>”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。</p>

<h2>3××</h2>

<p>3××类状态码表示客户端请求的资源发生了变动，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的“重定向”，包括著名的 301、302 跳转。</p>

<p>“<strong>301 Moved Permanently</strong>”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用改用新的 URI 再次访问。</p>

<p>与它类似的是“<strong>302 Found</strong>”，曾经的描述短语是“<strong>Moved Temporarily</strong>”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。</p>

<p>301 和 302 都会在响应头里使用字段<strong>Location</strong>指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大。</p>

<p>比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。</p>

<p>再比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。</p>

<p>“<strong>304 Not Modified</strong>” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。</p>

<p>301、302 和 304 分别涉及了 HTTP 协议里重要的“重定向跳转”和“缓存控制”，在之后的课程中我还会细讲。</p>

<h2>4××</h2>

<p>4××里剩下的一些代码较明确地说明了错误的原因，都很好理解，开发中常用的有：</p>

<p>4××类状态码表示客户端发送的请求报文有误，服务器无法处理，它就是真正的“错误码”含义了。</p>

<p>“<strong>400 Bad Request</strong>”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。</p>

<p>“<strong>403 Forbidden</strong>”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个“闭门羹”。</p>

<p>“<strong>404 Not Found</strong>”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所以无法提供给客户端。但现在已经被“用滥了”，只要服务器“不高兴”就可以给出个 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌。</p>

<p>4××里剩下的一些代码较明确地说明了错误的原因，都很好理解，开发中常用的有：</p>

<ul>
<li>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；</li>
<li>406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；</li>
<li>408 Request Timeout：请求超时，服务器等待了过长的时间；</li>
<li>409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；</li>
<li>413 Request Entity Too Large：请求报文里的 body 太大；</li>
<li>414 Request-URI Too Long：请求行里的 URI 太大；</li>
<li>429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；</li>
<li>431 Request Header Fields Too Large：请求头某个字段或总体太大；</li>
</ul>

<h2>5××</h2>

<p>5××类状态码表示客户端请求报文正确，但服务器在处理时内部发生了错误，无法返回应有的响应数据，是服务器端的“错误码”。</p>

<p>“<strong>500 Internal Server Error</strong>”与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。</p>

<p>“<strong>501 Not Implemented</strong>”表示客户端请求的功能还不支持，这个错误码比 500 要“温和”一些，和“即将开业，敬请期待”的意思差不多，不过具体什么时候“开业”就不好说了。</p>

<p>“<strong>502 Bad Gateway</strong>”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。</p>

<p>“<strong>503 Service Unavailable</strong>”表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。</p>

<p>503 是一个“临时”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个“<strong>Retry-After</strong>”字段，指示客户端可以在多久以后再次尝试发送请求。</p>

<h1 class="cZCVMzBP_0">13 | HTTP有哪些特点？</h1>

<p><img src="https://static001.geekbang.org/resource/image/78/4a/7808b195c921e0685958c20509855d4a.png" alt=""></p>

<h2>灵活可扩展</h2>

<p>首先， <span class="orange">HTTP 协议是一个“灵活可扩展”的传输协议</span>。</p>

<p>HTTP 协议最初诞生的时候就比较简单，本着开放的精神只规定了报文的基本格式，比如用空格分隔单词，用换行分隔字段，“header+body”等，报文里的各个组成部分都没有做严格的语法语义限制，可以由开发者任意定制。</p>

<h2>可靠传输</h2>

<p>第二个特点， <span class="orange">HTTP 协议是一个“可靠”的传输协议</span>。</p>

<p>这个特点显而易见，因为 HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传输协议，所以 HTTP 自然也就继承了这个特性，能够在请求方和应答方之间“可靠”地传输数据。</p>

<p>它的具体做法与 TCP/UDP 差不多，都是对实际传输的数据（entity）做了一层包装，加上一个头，然后调用 Socket API，通过 TCP/IP 协议栈发送或者接收。</p>

<p>不过我们必须正确地理解“可靠”的含义，HTTP 并不能 100% 保证数据一定能够发送到另一端，在网络繁忙、连接质量差等恶劣的环境下，也有可能收发失败。“可靠”只是向使用者提供了一个“承诺”，会在下层用多种手段“尽量”保证数据的完整送达。</p>

<h2>应用层协议</h2>

<p>第三个特点，<span class="orange">HTTP 协议是一个应用层的协议</span>。</p>

<p>在 TCP/IP 诞生后的几十年里，虽然出现了许多的应用层协议，但它们都仅关注很小的应用领域，局限在很少的应用场景。例如 FTP 只能传输文件、SMTP 只能发送邮件、SSH 只能远程登录等，在通用的数据传输方面“完全不能打”。</p>

<p>所以 HTTP 凭借着可携带任意头字段和实体数据的报文结构，以及连接控制、缓存代理等方便易用的特性，一出现就“技压群雄”，迅速成为了应用层里的“明星”协议。只要不太苛求性能，HTTP 几乎可以传递一切东西，满足各种需求，称得上是一个“万能”的协议。</p>

<h2>请求 - 应答</h2>

<p>第四个特点，<span class="orange">HTTP 协议使用的是请求 - 应答通信模式</span>。</p>

<p>这个请求 - 应答模式是 HTTP 协议最根本的通信模型，通俗来讲就是“一发一收”“有来有去”，就像是写代码时的函数调用，只要填好请求头里的字段，“调用”后就会收到答复。</p>

<p>请求 - 应答模式也明确了 HTTP 协议里通信双方的定位，永远是请求方先发起连接和请求，是主动的，而应答方只有在收到请求后才能答复，是被动的，如果没有请求时不会有任何动作。</p>

<h2>无状态</h2>

<p>第五个特点，<span class="orange">HTTP 协议是无状态的</span>。</p>

<p>“状态”其实就是客户端或者服务器里保存的一些数据或者标志，记录了通信过程中的一些变化信息。</p>

<p>你一定知道，TCP 协议是有状态的，一开始处于 CLOSED 状态，连接成功后是 ESTABLISHED 状态，断开连接后是 FIN-WAIT 状态，最后又是 CLOSED 状态。</p>

<p>这些“状态”就需要 TCP 在内部用一些数据结构去维护，可以简单地想象成是个标志量，标记当前所处的状态，例如 0 是 CLOSED，2 是 ESTABLISHED 等等。</p>

<p>再来看 HTTP，那么对比一下 TCP 就看出来了，在整个协议里没有规定任何的“状态”，客户端和服务器永远是处在一种“<strong>无知</strong>”的状态。建立连接前两者互不知情，每次收发的报文也都是互相独立的，没有任何的联系。收发报文也不会对客户端或服务器产生任何影响，连接后也不会要求保存任何信息。</p>

<p>“无状态”形象地来说就是“没有记忆能力”。比如，浏览器发了一个请求，说“我是小明，请给我 A 文件。”，服务器收到报文后就会检查一下权限，看小明确实可以访问 A 文件，于是把文件发回给浏览器。接着浏览器还想要 B 文件，但服务器不会记录刚才的请求状态，不知道第二个请求和第一个请求是同一个浏览器发来的，所以浏览器必须还得重复一次自己的身份才行：“我是刚才的小明，请再给我 B 文件。”</p>

<p>我们可以再对比一下 UDP 协议，不过它是无连接也无状态的，顺序发包乱序收包，数据包发出去后就不管了，收到后也不会顺序整理。而 HTTP 是有连接无状态，顺序发包顺序收包，按照收发的顺序管理报文。</p>

<h2>其他特点</h2>

<p>除了以上的五大特点，其实 HTTP 协议还可以列出非常多的特点，例如传输的实体数据可缓存可压缩、可分段获取数据、支持身份认证、支持国际化语言等。但这些并不能算是 HTTP 的基本特点，因为这都是由第一个“灵活可扩展”的特点所衍生出来的。</p>

<h1 class="cZCVMzBP_0">14 | HTTP/1.1有哪些优点？又有哪些缺点？</h1>

<h2>简单、灵活、易于扩展</h2>

<p>初次接触 HTTP 的人都会认为，HTTP 协议是很“<strong>简单</strong>”的，基本的报文格式就是“header+body”，头部信息也是简单的文本格式，用的也都是常见的英文单词，即使不去看 RFC 文档，只靠猜也能猜出个“八九不离十”。</p>

<p>HTTP 协议里的请求方法、URI、状态码、原因短语、头字段等每一个核心组成要素都没有被“写死”，允许开发者任意定制、扩充或解释，给予了浏览器和服务器最大程度的信任和自由，也正好符合了互联网“自由与平等”的精神——缺什么功能自己加个字段或者错误码什么的补上就是了。</p>

<p>“灵活、易于扩展”的特性还表现在 HTTP 对“可靠传输”的定义上，它不限制具体的下层协议，不仅可以使用 TCP、UNIX Domain Socket，还可以使用 SSL/TLS，甚至是基于 UDP 的 QUIC，下层可以随意变化，而上层的语义则始终保持稳定。</p>


<h2>应用广泛、环境成熟</h2>

<p>HTTP 协议的另一大优点是“<strong>应用广泛</strong>”，软硬件环境都非常成熟。</p>

<p>随着互联网特别是移动互联网的普及，HTTP 的触角已经延伸到了世界的每一个角落：从简单的 Web 页面到复杂的 JSON、XML 数据，从台式机上的浏览器到手机上的各种 APP，从看新闻、泡论坛到购物、理财、“吃鸡”，你很难找到一个没有使用 HTTP 的地方。</p>

<h2>无状态</h2>

<p>“无状态”有什么好处呢？</p>

<p>因为服务器没有“记忆能力”，所以就不需要额外的资源来记录状态信息，不仅实现上会简单一些，而且还能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</p>

<p>而且，“无状态”也表示服务器都是相同的，没有“状态”的差异，所以可以很容易地组成集群，让负载均衡把请求转发到任意一台服务器，不会因为状态不一致导致处理出错，使用“堆机器”的“笨办法”轻松实现高并发高可用。</p>

<p>那么，“无状态”又有什么坏处呢？</p>

<p>既然服务器没有“记忆能力”，它就无法支持需要连续多个步骤的“事务”操作。例如电商购物，首先要登录，然后添加购物车，再下单、结算、支付，这一系列操作都需要知道用户的身份才行，但“无状态”服务器是不知道这些请求是相互关联的，每次都得问一遍身份信息，不仅麻烦，而且还增加了不必要的数据传输量。</p>

<p>所以，HTTP 协议最好是既“无状态”又“有状态”，不过还真有“鱼和熊掌”两者兼得这样的好事，这就是“小甜饼”Cookie 技术（第 19 讲）。</p>

<h2>明文</h2>

<p>HTTP 协议里还有一把优缺点一体的“双刃剑”，就是<strong>明文传输</strong>。</p>

<p>“明文”意思就是协议里的报文（准确地说是 header 部分）不使用二进制数据，而是用简单可阅读的文本形式。</p>

<p>对比 TCP、UDP 这样的二进制协议，它的优点显而易见，不需要借助任何外部工具，用浏览器、Wireshark 或者 tcpdump 抓包后，直接用肉眼就可以很容易地查看或者修改，为我们的开发调试工作带来极大的便利。</p>

<p>当然，明文的缺点也是一样显而易见，HTTP 报文的所有信息都会暴露在“光天化日之下”，在漫长的传输链路的每一个环节上都毫无隐私可言，不怀好意的人只要侵入了这个链路里的某个设备，简单地“旁路”一下流量，就可以实现对通信的窥视。</p>

<h2>不安全</h2>

<p>与“明文”缺点相关但不完全等同的另一个缺点是“不安全”。</p>

<p>安全有很多的方面，明文只是“机密”方面的一个缺点，在“身份认证”和“完整性校验”这两方面 HTTP 也是欠缺的。</p>

<p>“身份认证”简单来说就是“<strong>怎么证明你就是你</strong>”。在现实生活中比较好办，你可以拿出身份证、驾照或者护照，上面有照片和权威机构的盖章，能够证明你的身份。</p>

<p>但在虚拟的网络世界里这却是个麻烦事。HTTP 没有提供有效的手段来确认通信双方的真实身份。虽然协议里有一个基本的认证机制，但因为刚才所说的明文传输缺点，这个机制几乎可以说是“纸糊的”，非常容易被攻破。如果仅使用 HTTP 协议，很可能你会连到一个页面一模一样但却是个假冒的网站，然后再被“钓”走各种私人信息。</p>

<h2>性能</h2>

<p>最后我们来谈谈 HTTP 的性能，可以用六个字来概括：“<strong>不算差，不够好</strong>”。</p>

<p>HTTP 协议基于 TCP/IP，并且使用了“请求 - 应答”的通信模式，所以性能的关键就在这两点上。</p>

<p>必须要说的是，TCP 的性能是不差的，否则也不会纵横互联网江湖四十余载了，而且它已经被研究的很透，集成在操作系统内核里经过了细致的优化，足以应付大多数的场景。</p>

<p>而“请求 - 应答”模式则加剧了 HTTP 的性能问题，这就是著名的“队头阻塞”（Head-of-line blocking），当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。</p>

<h2 class="se-c47a5a85" data-slate-type="heading" data-slate-object="block" data-key="319"><span data-slate-object="text" data-key="320"><span data-slate-leaf="true" data-offset-key="320:0" data-first-offset="true"><span data-slate-string="true">数据类型与编码</span></span></span></h2>

<div class="se-dd247802 " data-slate-type="paragraph" data-slate-object="block" data-key="321"><span data-slate-object="text" data-key="322"><span data-slate-leaf="true" data-offset-key="322:0" data-first-offset="true"><span data-slate-string="true">在 TCP/IP 协议栈里，传输数据基本上都是“header+body”的格式。但 TCP、UDP 因为是传输层的协议，它们不会关心 body 数据是什么，只要把数据发送到对方就算是完成了任务。</span></span></span></div>

<div class="se-d94d4844 " data-slate-type="paragraph" data-slate-object="block" data-key="323"><span data-slate-object="text" data-key="324"><span data-slate-leaf="true" data-offset-key="324:0" data-first-offset="true"><span data-slate-string="true">而 HTTP 协议则不同，它是应用层的协议，数据到达之后工作只能说是完成了一半，还必须要告诉上层应用这是什么数据才行，否则上层应用就会“不知所措”。</span></span></span></div>

<div class="se-64269a7e " data-slate-type="paragraph" data-slate-object="block" data-key="329"><span data-slate-object="text" data-key="330"><span data-slate-leaf="true" data-offset-key="330:0" data-first-offset="true"><span data-slate-string="true">幸运的是，早在 HTTP 协议诞生之前就已经有了针对这种问题的解决方案，不过它是用在电子邮件系统里的，让电子邮件可以发送 ASCII 码以外的任意数据，方案的名字叫做“</span></span></span><span data-slate-object="text" data-key="331"><span data-slate-leaf="true" data-offset-key="331:0" data-first-offset="true"><span class="se-8add6ef7" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">多用途互联网邮件扩展</span></span></span></span><span data-slate-object="text" data-key="332"><span data-slate-leaf="true" data-offset-key="332:0" data-first-offset="true"><span data-slate-string="true">”（Multipurpose Internet Mail Extensions），简称为 MIME。</span></span></span></div>

<div class="se-10e43be4 " data-slate-type="paragraph" data-slate-object="block" data-key="337"><span data-slate-object="text" data-key="338"><span data-slate-leaf="true" data-offset-key="338:0" data-first-offset="true"><span data-slate-string="true">MIME 把数据分成了八大类，每个大类下再细分出多个子类，形式是“type/subtype”的字符串，巧得很，刚好也符合了 HTTP 明文的特点，所以能够很容易地纳入 HTTP 头字段里。</span></span></span></div>

<div class="se-dfc490d1 " data-slate-type="paragraph" data-slate-object="block" data-key="339"><span data-slate-object="text" data-key="340"><span data-slate-leaf="true" data-offset-key="340:0" data-first-offset="true"><span data-slate-string="true">这里简单列举一下在 HTTP 里经常遇到的几个类别：</span></span></span></div>

<div class="se-64407345" data-slate-type="list" data-slate-object="block" data-key="341"><div class="se-4520178c" data-slate-type="list-line" data-slate-object="block" data-key="342"><div class="se-11671887 se-98a3ec7e" data-code-line-number="1"></div><div class="se-d4f17b05"><span data-slate-object="text" data-key="343"><span data-slate-leaf="true" data-offset-key="343:0" data-first-offset="true"><span data-slate-string="true">text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。</span></span></span></div></div><div class="se-f2cb4177" data-slate-type="list-line" data-slate-object="block" data-key="344"><div class="se-1103a2e0 se-8b40b342" data-code-line-number="2"></div><div class="se-2bf92c1a"><span data-slate-object="text" data-key="345"><span data-slate-leaf="true" data-offset-key="345:0" data-first-offset="true"><span data-slate-string="true">image：即图像文件，有 image/gif、image/jpeg、image/png 等。</span></span></span></div></div><div class="se-ecd91dd5" data-slate-type="list-line" data-slate-object="block" data-key="346"><div class="se-bd661cb0 se-d6fca9d6" data-code-line-number="3"></div><div class="se-133b6932"><span data-slate-object="text" data-key="347"><span data-slate-leaf="true" data-offset-key="347:0" data-first-offset="true"><span data-slate-string="true">audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。</span></span></span></div></div><div class="se-a05beb49" data-slate-type="list-line" data-slate-object="block" data-key="348"><div class="se-cd5617be se-a616e389" data-code-line-number="4"></div><div class="se-0c3d5b8f"><span data-slate-object="text" data-key="349"><span data-slate-leaf="true" data-offset-key="349:0" data-first-offset="true"><span data-slate-string="true">application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据。</span></span></span></div></div></div>

<div class="se-45713481 " data-slate-type="paragraph" data-slate-object="block" data-key="350"><span data-slate-object="text" data-key="351"><span data-slate-leaf="true" data-offset-key="351:0" data-first-offset="true"><span data-slate-string="true">但仅有 MIME type 还不够，因为 HTTP 在传输时为了节约带宽，有时候还会压缩数据，为了不要让浏览器继续“猜”，还需要有一个“Encoding type”，告诉数据是用的什么编码格式，这样对方才能正确解压缩，还原出原始的数据。</span></span></span></div>

<div class="se-052ba2b8 " data-slate-type="paragraph" data-slate-object="block" data-key="352"><span data-slate-object="text" data-key="353"><span data-slate-leaf="true" data-offset-key="353:0" data-first-offset="true"><span data-slate-string="true">比起 MIME type 来说，Encoding type 就少了很多，常用的只有下面三种：</span></span></span></div>

<div class="se-13075bd2" data-slate-type="list" data-slate-object="block" data-key="354"><div class="se-35a77835" data-slate-type="list-line" data-slate-object="block" data-key="355"><div class="se-d03e8e00 se-a1bb3846" data-code-line-number="1"></div><div class="se-02a19242"><span data-slate-object="text" data-key="356"><span data-slate-leaf="true" data-offset-key="356:0" data-first-offset="true"><span data-slate-string="true">gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；</span></span></span></div></div><div class="se-522693a4" data-slate-type="list-line" data-slate-object="block" data-key="357"><div class="se-63a8da16 se-4073b366" data-code-line-number="2"></div><div class="se-fdcfd295"><span data-slate-object="text" data-key="358"><span data-slate-leaf="true" data-offset-key="358:0" data-first-offset="true"><span data-slate-string="true">deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；</span></span></span></div></div><div class="se-01be9422" data-slate-type="list-line" data-slate-object="block" data-key="359"><div class="se-a32e9e89 se-67dd59f1" data-code-line-number="3"></div><div class="se-bd7e8e24"><span data-slate-object="text" data-key="360"><span data-slate-leaf="true" data-offset-key="360:0" data-first-offset="true"><span data-slate-string="true">br：一种专门为 HTTP 优化的新压缩算法（Brotli）。</span></span></span></div></div></div>

<h2 class="se-1e0caf2c" data-slate-type="heading" data-slate-object="block" data-key="51"><span data-slate-object="text" data-key="52"><span data-slate-leaf="true" data-offset-key="52:0" data-first-offset="true"><span data-slate-string="true">数据类型使用的头字段</span></span></span></h2>

<div class="se-c82c376e " data-slate-type="paragraph" data-slate-object="block" data-key="55"><span data-slate-object="text" data-key="56"><span data-slate-leaf="true" data-offset-key="56:0" data-first-offset="true"><span data-slate-string="true">HTTP 协议为此定义了两个 Accept 请求头字段和两个 Content 实体头字段，用于客户端和服务器进行“</span></span></span><span data-slate-object="text" data-key="57"><span data-slate-leaf="true" data-offset-key="57:0" data-first-offset="true"><span class="se-be2d2c73" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">内容协商</span></span></span></span><span data-slate-object="text" data-key="58"><span data-slate-leaf="true" data-offset-key="58:0" data-first-offset="true"><span data-slate-string="true">”。也就是说，客户端用 Accept 头告诉服务器希望接收什么样的数据，而服务器用 Content 头告诉客户端实际发送了什么样的数据。</span></span></span></div>

<div class="se-649022f5" data-slate-type="image" data-slate-object="block" data-key="59"><img class="se-1b66daa4" src="https://static001.geekbang.org/resource/image/51/b9/5191bce1329efa157a6cc37ab9e789b9.png"></div>

<div class="se-ebcf25d0 " data-slate-type="paragraph" data-slate-object="block" data-key="60"><span data-slate-object="text" data-key="61"><span data-slate-leaf="true" data-offset-key="61:0" data-first-offset="true"><span class="se-0b6821a4" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Accept</span></span></span></span><span data-slate-object="text" data-key="62"><span data-slate-leaf="true" data-offset-key="62:0" data-first-offset="true"><span data-slate-string="true">字段标记的是客户端可理解的 MIME type，可以用“,”做分隔符列出多个类型，让服务器有更多的选择余地，例如下面的这个头：</span></span></span></div>

<div class="se-c677cd89 se-4e97403a" data-slate-type="pre" data-slate-object="block" data-key="63"><div class="se-f221d1ef se-e37e38e1"><span></span></div><div class="se-5d6662a5"><div class="se-dddf4cfa se-2391916d" data-code-line-number="1"></div></div><div class="se-c5611542 ps"><div class="se-96a6bc5c se-bc69363b" data-slate-type="code-line" data-slate-object="block" data-key="64"><span data-slate-object="text" data-key="65"><span data-slate-leaf="true" data-offset-key="65:0" data-first-offset="true"><span data-slate-string="true">Accept: text/html,application/xml,image/webp,image/png</span></span></span></div><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></div>

<div class="se-4cc23fdc " data-slate-type="paragraph" data-slate-object="block" data-key="66"><span data-slate-object="text" data-key="67"><span data-slate-leaf="true" data-offset-key="67:0" data-first-offset="true"><span data-slate-string="true">这就是告诉服务器：“我能够看懂 HTML、XML 的文本，还有 webp 和 png 的图片，请给我这四类格式的数据”。</span></span></span></div>

<div class="se-66d25b04 " data-slate-type="paragraph" data-slate-object="block" data-key="79"><span data-slate-object="text" data-key="80"><span data-slate-leaf="true" data-offset-key="80:0" data-first-offset="true"><span class="se-3cb846d5" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Accept-Encoding</span></span></span></span><span data-slate-object="text" data-key="81"><span data-slate-leaf="true" data-offset-key="81:0" data-first-offset="true"><span data-slate-string="true">字段标记的是客户端支持的压缩格式，例如上面说的 gzip、deflate 等，同样也可以用“,”列出多个，服务器可以选择其中一种来压缩数据，实际使用的压缩格式放在响应头字段</span></span></span><span data-slate-object="text" data-key="82"><span data-slate-leaf="true" data-offset-key="82:0" data-first-offset="true"><span class="se-937a8807" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Content-Encoding</span></span></span></span><span data-slate-object="text" data-key="83"><span data-slate-leaf="true" data-offset-key="83:0" data-first-offset="true"><span data-slate-string="true">里。</span></span></span></div>

<div class="se-452adc5d se-3a62baa4" data-slate-type="pre" data-slate-object="block" data-key="84"><div class="se-09943b90 se-4a34dd8b"><span></span></div><div class="se-41e47c6d"><div class="se-7f35130b se-58d6d589" data-code-line-number="1"></div><div class="se-7f35130b se-58d6d589" data-code-line-number="2"></div></div><div class="se-620b82f2 ps"><div class="se-96a6bc5c se-bc69363b" data-slate-type="code-line" data-slate-object="block" data-key="85"><span data-slate-object="text" data-key="86"><span data-slate-leaf="true" data-offset-key="86:0" data-first-offset="true"><span data-slate-string="true">Accept-Encoding: gzip, deflate, br</span></span></span></div><div class="se-96a6bc5c se-bc69363b" data-slate-type="code-line" data-slate-object="block" data-key="87"><span data-slate-object="text" data-key="88"><span data-slate-leaf="true" data-offset-key="88:0" data-first-offset="true"><span data-slate-string="true">Content-Encoding: gzip</span></span></span></div><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></div>

<div class="se-719ec8d6 " data-slate-type="paragraph" data-slate-object="block" data-key="89"><span data-slate-object="text" data-key="90"><span data-slate-leaf="true" data-offset-key="90:0" data-first-offset="true"><span data-slate-string="true">不过这两个字段是可以省略的，如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据；如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩。</span></span></span></div>

<h2 class="se-1ac1bda4" data-slate-type="heading" data-slate-object="block" data-key="91"><span data-slate-object="text" data-key="92"><span data-slate-leaf="true" data-offset-key="92:0" data-first-offset="true"><span data-slate-string="true">语言类型与编码</span></span></span></h2>

<div class="se-9bc4cdcb " data-slate-type="paragraph" data-slate-object="block" data-key="95"><span data-slate-object="text" data-key="96"><span data-slate-leaf="true" data-offset-key="96:0" data-first-offset="true"><span data-slate-string="true">这实际上就是“国际化”的问题。HTTP 采用了与数据类型相似的解决方案，又引入了两个概念：语言类型与字符集。</span></span></span></div>

<div class="se-e42f0912 " data-slate-type="paragraph" data-slate-object="block" data-key="97"><span data-slate-object="text" data-key="98"><span data-slate-leaf="true" data-offset-key="98:0" data-first-offset="true"><span data-slate-string="true">所谓的“</span></span></span><span data-slate-object="text" data-key="99"><span data-slate-leaf="true" data-offset-key="99:0" data-first-offset="true"><span class="se-104aeeed" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">语言类型</span></span></span></span><span data-slate-object="text" data-key="100"><span data-slate-leaf="true" data-offset-key="100:0" data-first-offset="true"><span data-slate-string="true">”就是人类使用的自然语言，例如英语、汉语、日语等，而这些自然语言可能还有下属的地区性方言，所以在需要明确区分的时候也要使用“type-subtype”的形式，不过这里的格式与数据类型不同，</span></span></span><span data-slate-object="text" data-key="101"><span data-slate-leaf="true" data-offset-key="101:0" data-first-offset="true"><span class="se-28627d29" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">分隔符不是“/”，而是“-”</span></span></span></span><span data-slate-object="text" data-key="102"><span data-slate-leaf="true" data-offset-key="102:0" data-first-offset="true"><span data-slate-string="true">。</span></span></span></div>

<div class="se-2adb839d " data-slate-type="paragraph" data-slate-object="block" data-key="103"><span data-slate-object="text" data-key="104"><span data-slate-leaf="true" data-offset-key="104:0" data-first-offset="true"><span data-slate-string="true">举几个例子：en 表示任意的英语，en-US 表示美式英语，en-GB 表示英式英语，而 zh-CN 就表示我们最常使用的汉语。</span></span></span></div>

<div class="se-c96c3989 " data-slate-type="paragraph" data-slate-object="block" data-key="107"><span data-slate-object="text" data-key="108"><span data-slate-leaf="true" data-offset-key="108:0" data-first-offset="true"><span data-slate-string="true">在计算机发展的早期，各个国家和地区的人们“各自为政”，发明了许多字符编码方式来处理文字，比如英语世界用的 ASCII、汉语世界用的 GBK、BIG5，日语世界用的 Shift_JIS 等。同样的一段文字，用一种编码显示正常，换另一种编码后可能就会变得一团糟。</span></span></span></div>

<div class="se-62710dfc " data-slate-type="paragraph" data-slate-object="block" data-key="109"><span data-slate-object="text" data-key="110"><span data-slate-leaf="true" data-offset-key="110:0" data-first-offset="true"><span data-slate-string="true">所以后来就出现了 Unicode 和 UTF-8，把世界上所有的语言都容纳在一种编码方案里，遵循 UTF-8 字符编码方式的 Unicode 字符集也成为了互联网上的标准字符集。</span></span></span></div>

<h2 class="se-72f28e3e" data-slate-type="heading" data-slate-object="block" data-key="111"><span data-slate-object="text" data-key="112"><span data-slate-leaf="true" data-offset-key="112:0" data-first-offset="true"><span data-slate-string="true">语言类型使用的头字段</span></span></span></h2>

<div class="se-74407edb " data-slate-type="paragraph" data-slate-object="block" data-key="113"><span data-slate-object="text" data-key="114"><span data-slate-leaf="true" data-offset-key="114:0" data-first-offset="true"><span data-slate-string="true">同样的，HTTP 协议也使用 Accept 请求头字段和 Content 实体头字段，用于客户端和服务器就语言与编码进行“</span></span></span><span data-slate-object="text" data-key="115"><span data-slate-leaf="true" data-offset-key="115:0" data-first-offset="true"><span class="se-ed28bca5" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">内容协商</span></span></span></span><span data-slate-object="text" data-key="116"><span data-slate-leaf="true" data-offset-key="116:0" data-first-offset="true"><span data-slate-string="true">”。</span></span></span></div>

<div class="se-00016135 " data-slate-type="paragraph" data-slate-object="block" data-key="117"><span data-slate-object="text" data-key="118"><span data-slate-leaf="true" data-offset-key="118:0" data-first-offset="true"><span class="se-667dc0f9" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Accept-Language</span></span></span></span><span data-slate-object="text" data-key="119"><span data-slate-leaf="true" data-offset-key="119:0" data-first-offset="true"><span data-slate-string="true">字段标记了客户端可理解的自然语言，也允许用“,”做分隔符列出多个类型，例如：</span></span></span></div>

<div class="se-1cc9d7e2 se-36dbf4e2" data-slate-type="pre" data-slate-object="block" data-key="120"><div class="se-7ac7b889 se-2e95a283"><span></span></div><div class="se-d5a81caa"><div class="se-fadf547e se-242f3ee9" data-code-line-number="1"></div></div><div class="se-7a1984c8 ps"><div class="se-96a6bc5c se-bc69363b" data-slate-type="code-line" data-slate-object="block" data-key="121"><span data-slate-object="text" data-key="122"><span data-slate-leaf="true" data-offset-key="122:0" data-first-offset="true"><span data-slate-string="true">Accept-Language: zh-CN, zh, en</span></span></span></div><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></div>

<div class="se-d45f430e " data-slate-type="paragraph" data-slate-object="block" data-key="123"><span data-slate-object="text" data-key="124"><span data-slate-leaf="true" data-offset-key="124:0" data-first-offset="true"><span data-slate-string="true">这个请求头会告诉服务器：“最好给我 zh-CN 的汉语文字，如果没有就用其他的汉语方言，如果还没有就给英文”。</span></span></span></div>

<div class="se-699a3840 " data-slate-type="paragraph" data-slate-object="block" data-key="125"><span data-slate-object="text" data-key="126"><span data-slate-leaf="true" data-offset-key="126:0" data-first-offset="true"><span data-slate-string="true">相应的，服务器应该在响应报文里用头字段</span></span></span><span data-slate-object="text" data-key="127"><span data-slate-leaf="true" data-offset-key="127:0" data-first-offset="true"><span class="se-ceeedca5" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Content-Language</span></span></span></span><span data-slate-object="text" data-key="128"><span data-slate-leaf="true" data-offset-key="128:0" data-first-offset="true"><span data-slate-string="true">告诉客户端实体数据使用的实际语言类型：</span></span></span></div>

<div class="se-fee2e3b4 se-963c770f" data-slate-type="pre" data-slate-object="block" data-key="129"><div class="se-fb526603 se-51769154"><span></span></div><div class="se-e1c1f030"><div class="se-232bb9b9 se-144ce391" data-code-line-number="1"></div></div><div class="se-d9337515 ps"><div class="se-96a6bc5c se-bc69363b" data-slate-type="code-line" data-slate-object="block" data-key="130"><span data-slate-object="text" data-key="131"><span data-slate-leaf="true" data-offset-key="131:0" data-first-offset="true"><span data-slate-string="true">Content-Language: zh-CN</span></span></span></div><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></div>

<div class="se-ad51b2a1 " data-slate-type="paragraph" data-slate-object="block" data-key="132"><span data-slate-object="text" data-key="133"><span data-slate-leaf="true" data-offset-key="133:0" data-first-offset="true"><span data-slate-string="true">字符集在 HTTP 里使用的请求头字段是</span></span></span><span data-slate-object="text" data-key="134"><span data-slate-leaf="true" data-offset-key="134:0" data-first-offset="true"><span class="se-4e095110" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Accept-Charset</span></span></span></span><span data-slate-object="text" data-key="135"><span data-slate-leaf="true" data-offset-key="135:0" data-first-offset="true"><span data-slate-string="true">，但响应头里却没有对应的 Content-Charset，而是在</span></span></span><span data-slate-object="text" data-key="136"><span data-slate-leaf="true" data-offset-key="136:0" data-first-offset="true"><span class="se-4b79a1a6" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Content-Type</span></span></span></span><span data-slate-object="text" data-key="137"><span data-slate-leaf="true" data-offset-key="137:0" data-first-offset="true"><span data-slate-string="true">字段的数据类型后面用“charset=xxx”来表示，这点需要特别注意。</span></span></span></div>

<div class="se-c5ca03f4 se-e8d13e0e" data-slate-type="pre" data-slate-object="block" data-key="140"><div class="se-07805a73 se-f53a15fb"><span></span></div><div class="se-df653068"><div class="se-eeb32cde se-6734d3d9" data-code-line-number="1"></div><div class="se-eeb32cde se-6734d3d9" data-code-line-number="2"></div></div><div class="se-fd487191 ps"><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="141"><span data-slate-object="text" data-key="142"><span data-slate-leaf="true" data-offset-key="142:0" data-first-offset="true"><span data-slate-string="true">Accept-Charset: gbk, utf-8</span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="143"><span data-slate-object="text" data-key="144"><span data-slate-leaf="true" data-offset-key="144:0" data-first-offset="true"><span data-slate-string="true">Content-Type: text/html; charset=utf-8</span></span></span></div><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></div>

<div class="se-664eb43f " data-slate-type="paragraph" data-slate-object="block" data-key="145"><span data-slate-object="text" data-key="146"><span data-slate-leaf="true" data-offset-key="146:0" data-first-offset="true"><span data-slate-string="true">不过现在的浏览器都支持多种字符集，通常不会发送 Accept-Charset，而服务器也不会发送 Content-Language，因为使用的语言完全可以由字符集推断出来，所以在请求头里一般只会有 Accept-Language 字段，响应头里只会有 Content-Type 字段。</span></span></span></div>

<div class="se-cae88e8f" data-slate-type="image" data-slate-object="block" data-key="147"><img class="se-56216fe8" src="https://static001.geekbang.org/resource/image/0e/10/0e9bcd6922fa8908bdba79d98ae5fa10.png"></div>

<h2 class="se-e383aafe" data-slate-type="heading" data-slate-object="block" data-key="148"><span data-slate-object="text" data-key="149"><span data-slate-leaf="true" data-offset-key="149:0" data-first-offset="true"><span data-slate-string="true">内容协商的质量值</span></span></span></h2>

<div class="se-fa05cb1e " data-slate-type="paragraph" data-slate-object="block" data-key="150"><span data-slate-object="text" data-key="151"><span data-slate-leaf="true" data-offset-key="151:0" data-first-offset="true"><span data-slate-string="true">在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可以用一种特殊的“q”参数表示权重来设定优先级，这里的“q”是“quality factor”的意思。</span></span></span></div>

<div class="se-5aa2265e " data-slate-type="paragraph" data-slate-object="block" data-key="152"><span data-slate-object="text" data-key="153"><span data-slate-leaf="true" data-offset-key="153:0" data-first-offset="true"><span data-slate-string="true">权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个“;”，然后是“q=value”。</span></span></span></div>

<div class="se-871a0ec6 " data-slate-type="paragraph" data-slate-object="block" data-key="154"><span data-slate-object="text" data-key="155"><span data-slate-leaf="true" data-offset-key="155:0" data-first-offset="true"><span data-slate-string="true">这里要提醒的是“;”的用法，在大多数编程语言里“;”的断句语气要强于“,”，而在 HTTP 的内容协商里却恰好反了过来，“;”的意义是小于“,”的。</span></span></span></div>

<div class="se-7ce5cec9 " data-slate-type="paragraph" data-slate-object="block" data-key="156"><span data-slate-object="text" data-key="157"><span data-slate-leaf="true" data-offset-key="157:0" data-first-offset="true"><span data-slate-string="true">例如下面的 Accept 字段：</span></span></span></div>

<div class="se-8d0c0c55 se-a81a87a6" data-slate-type="pre" data-slate-object="block" data-key="158"><div class="se-a3af7be5 se-b83f8bab"><span></span></div><div class="se-d773a67b"><div class="se-987e8593 se-bcd338d1" data-code-line-number="1"></div></div><div class="se-3ff78085 ps"><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="159"><span data-slate-object="text" data-key="160"><span data-slate-leaf="true" data-offset-key="160:0" data-first-offset="true"><span data-slate-string="true">Accept: text/html,application/xml;q=0.9,*/*;q=0.8</span></span></span></div><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></div>

<div class="se-5c1ec7f7 " data-slate-type="paragraph" data-slate-object="block" data-key="161"><span data-slate-object="text" data-key="162"><span data-slate-leaf="true" data-offset-key="162:0" data-first-offset="true"><span data-slate-string="true">它表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。</span></span></span></div>

<h2 class="se-ef1651d7" data-slate-type="heading" data-slate-object="block" data-key="163"><span data-slate-object="text" data-key="164"><span data-slate-leaf="true" data-offset-key="164:0" data-first-offset="true"><span data-slate-string="true">内容协商的结果</span></span></span></h2>

<div class="se-05a0a4d4 " data-slate-type="paragraph" data-slate-object="block" data-key="165"><span data-slate-object="text" data-key="166"><span data-slate-leaf="true" data-offset-key="166:0" data-first-offset="true"><span data-slate-string="true">内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个</span></span></span><span data-slate-object="text" data-key="167"><span data-slate-leaf="true" data-offset-key="167:0" data-first-offset="true"><span class="se-71e97267" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Vary</span></span></span></span><span data-slate-object="text" data-key="168"><span data-slate-leaf="true" data-offset-key="168:0" data-first-offset="true"><span data-slate-string="true">字段，记录服务器在内容协商时参考的请求头字段，给出一点信息，例如：</span></span></span></div>

<div class="se-33d1664d se-6d13b85d" data-slate-type="pre" data-slate-object="block" data-key="169"><div class="se-dd6939b5 se-07bc5d75"><span></span></div><div class="se-709f920a"><div class="se-1984023a se-548aed45" data-code-line-number="1"></div></div><div class="se-8aa2bb65 ps"><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="170"><span data-slate-object="text" data-key="171"><span data-slate-leaf="true" data-offset-key="171:0" data-first-offset="true"><span data-slate-string="true">Vary: Accept-Encoding,User-Agent,Accept</span></span></span></div><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></div>

<div class="se-931d131e " data-slate-type="paragraph" data-slate-object="block" data-key="172"><span data-slate-object="text" data-key="173"><span data-slate-leaf="true" data-offset-key="173:0" data-first-offset="true"><span data-slate-string="true">这个 Vary 字段表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的响应报文。</span></span></span></div>

<div class="se-2981e040 " data-slate-type="paragraph" data-slate-object="block" data-key="174"><span data-slate-object="text" data-key="175"><span data-slate-leaf="true" data-offset-key="175:0" data-first-offset="true"><span data-slate-string="true">Vary 字段可以认为是响应报文的一个特殊的“版本标记”。每当 Accept 等请求头变化时，Vary 也会随着响应报文一起变化。也就是说，同一个 URI 可能会有多个不同的“版本”，主要用在传输链路中间的代理服务器实现缓存服务，这个之后讲“HTTP 缓存”时还会再提到。</span></span></span></div>

<div class="se-70434cba" data-slate-type="image" data-slate-object="block" data-key="196"><img class="se-d0482412" src="https://static001.geekbang.org/resource/image/b2/58/b2118315a977969ddfcc7ab9d26cb358.png"></div>

<div class="se-23050297" data-slate-type="list" data-slate-object="block" data-key="197"><div class="se-efde4170" data-slate-type="list-line" data-slate-object="block" data-key="198"><div class="se-e5910d63 se-a42d9925" data-code-line-number="1"></div><div class="se-0db8b72c"><span data-slate-object="text" data-key="199"><span data-slate-leaf="true" data-offset-key="199:0" data-first-offset="true"><span class="se-2dc32765" data-slate-type="primary" data-slate-object="mark"><span data-slate-string="true">数据类型表示实体数据的内容是什么，使用的是 MIME type，相关的头字段是 Accept 和 Content-Type；</span></span></span></span></div></div><div class="se-311cc172" data-slate-type="list-line" data-slate-object="block" data-key="200"><div class="se-f48c7761 se-6e993ee8" data-code-line-number="2"></div><div class="se-4aa1683c"><span data-slate-object="text" data-key="201"><span data-slate-leaf="true" data-offset-key="201:0" data-first-offset="true"><span class="se-2dc32765" data-slate-type="primary" data-slate-object="mark"><span data-slate-string="true">数据编码表示实体数据的压缩方式，相关的头字段是 Accept-Encoding 和 Content-Encoding；</span></span></span></span></div></div><div class="se-26783f8d" data-slate-type="list-line" data-slate-object="block" data-key="202"><div class="se-06a695bd se-413b8169" data-code-line-number="3"></div><div class="se-fab704ff"><span data-slate-object="text" data-key="203"><span data-slate-leaf="true" data-offset-key="203:0" data-first-offset="true"><span class="se-2dc32765" data-slate-type="primary" data-slate-object="mark"><span data-slate-string="true">语言类型表示实体数据的自然语言，相关的头字段是 Accept-Language 和 Content-Language；</span></span></span></span></div></div><div class="se-862d4154" data-slate-type="list-line" data-slate-object="block" data-key="204"><div class="se-256b1bd1 se-fa1c4226" data-code-line-number="4"></div><div class="se-b89310f2"><span data-slate-object="text" data-key="205"><span data-slate-leaf="true" data-offset-key="205:0" data-first-offset="true"><span class="se-2dc32765" data-slate-type="primary" data-slate-object="mark"><span data-slate-string="true">字符集表示实体数据的编码方式，相关的头字段是 Accept-Charset 和 Content-Type；</span></span></span></span></div></div><div class="se-f0e0d873" data-slate-type="list-line" data-slate-object="block" data-key="206"><div class="se-b2725bab se-1430f545" data-code-line-number="5"></div><div class="se-1195bf89"><span data-slate-object="text" data-key="207"><span data-slate-leaf="true" data-offset-key="207:0" data-first-offset="true"><span class="se-2dc32765" data-slate-type="primary" data-slate-object="mark"><span data-slate-string="true">客户端需要在请求头里使用 Accept 等头字段与服务器进行“内容协商”，要求服务器返回最合适的数据；</span></span></span></span></div></div><div class="se-8c1aa31d" data-slate-type="list-line" data-slate-object="block" data-key="208"><div class="se-dcd4bac5 se-d428ed6b" data-code-line-number="6"></div><div class="se-ad98fb70"><span data-slate-object="text" data-key="209"><span data-slate-leaf="true" data-offset-key="209:0" data-first-offset="true"><span class="se-2dc32765" data-slate-type="primary" data-slate-object="mark"><span data-slate-string="true">Accept 等头字段可以用“,”顺序列出多个可能的选项，还可以用“;q=”参数来精确指定权重。</span></span></span></span></div></div></div>

<h1 class="cZCVMzBP_0">HTTP传输大文件的方法</h1>

<h2 class="se-c31cadae" data-slate-type="heading" data-slate-object="block" data-key="237"><span data-slate-object="text" data-key="238"><span data-slate-leaf="true" data-offset-key="238:0" data-first-offset="true"><span data-slate-string="true">数据压缩</span></span></span></h2>

<div class="se-b638d78c " data-slate-type="paragraph" data-slate-object="block" data-key="239"><span data-slate-object="text" data-key="240"><span data-slate-leaf="true" data-offset-key="240:0" data-first-offset="true"><span data-slate-string="true">还记得上一讲中说到的“数据类型与编码”吗？如果你还有印象的话，肯定能够想到一个最基本的解决方案，那就是“</span></span></span><span data-slate-object="text" data-key="241"><span data-slate-leaf="true" data-offset-key="241:0" data-first-offset="true"><span class="se-90766ba7" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">数据压缩</span></span></span></span><span data-slate-object="text" data-key="242"><span data-slate-leaf="true" data-offset-key="242:0" data-first-offset="true"><span data-slate-string="true">”，把大象变成小猪佩奇，再放进冰箱。</span></span></span></div>

<div class="se-7d1d7880 " data-slate-type="paragraph" data-slate-object="block" data-key="243"><span data-slate-object="text" data-key="244"><span data-slate-leaf="true" data-offset-key="244:0" data-first-offset="true"><span data-slate-string="true">通常浏览器在发送请求时都会带着“</span></span></span><span data-slate-object="text" data-key="245"><span data-slate-leaf="true" data-offset-key="245:0" data-first-offset="true"><span class="se-0c24f960" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Accept-Encoding</span></span></span></span><span data-slate-object="text" data-key="246"><span data-slate-leaf="true" data-offset-key="246:0" data-first-offset="true"><span data-slate-string="true">”头字段，里面是浏览器支持的压缩格式列表，例如 gzip、deflate、br 等，这样服务器就可以从中选择一种压缩算法，放进“</span></span></span><span data-slate-object="text" data-key="247"><span data-slate-leaf="true" data-offset-key="247:0" data-first-offset="true"><span class="se-bcdf8ac9" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Content-Encoding</span></span></span></span><span data-slate-object="text" data-key="248"><span data-slate-leaf="true" data-offset-key="248:0" data-first-offset="true"><span data-slate-string="true">”响应头里，再把原数据压缩后发给浏览器。</span></span></span></div>

<div class="se-a256344f " data-slate-type="paragraph" data-slate-object="block" data-key="251"><span data-slate-object="text" data-key="252"><span data-slate-leaf="true" data-offset-key="252:0" data-first-offset="true"><span data-slate-string="true">不过这个解决方法也有个缺点，gzip 等压缩算法通常只对文本文件有较好的压缩率，而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理也不会变小（甚至还有可能会增大一点），所以它就失效了。</span></span></span></div>

<h2 class="se-17ff2e12" data-slate-type="heading" data-slate-object="block" data-key="255"><span data-slate-object="text" data-key="256"><span data-slate-leaf="true" data-offset-key="256:0" data-first-offset="true"><span data-slate-string="true">分块传输</span></span></span></h2>

<div class="se-660970cf " data-slate-type="paragraph" data-slate-object="block" data-key="259"><span data-slate-object="text" data-key="260"><span data-slate-leaf="true" data-offset-key="260:0" data-first-offset="true"><span data-slate-string="true">压缩是把大文件整体变小，我们可以反过来思考，如果大文件整体不能变小，那就把它“拆开”，分解成多个小块，把这些小块分批发给浏览器，浏览器收到后再组装复原。</span></span></span></div>

<div class="se-8c34a6de " data-slate-type="paragraph" data-slate-object="block" data-key="263"><span data-slate-object="text" data-key="264"><span data-slate-leaf="true" data-offset-key="264:0" data-first-offset="true"><span data-slate-string="true">这种“</span></span></span><span data-slate-object="text" data-key="265"><span data-slate-leaf="true" data-offset-key="265:0" data-first-offset="true"><span class="se-32532e81" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">化整为零</span></span></span></span><span data-slate-object="text" data-key="266"><span data-slate-leaf="true" data-offset-key="266:0" data-first-offset="true"><span data-slate-string="true">”的思路在 HTTP 协议里就是“</span></span></span><span data-slate-object="text" data-key="267"><span data-slate-leaf="true" data-offset-key="267:0" data-first-offset="true"><span class="se-a913195e" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">chunked</span></span></span></span><span data-slate-object="text" data-key="268"><span data-slate-leaf="true" data-offset-key="268:0" data-first-offset="true"><span data-slate-string="true">”分块传输编码，在响应报文里用头字段“</span></span></span><span data-slate-object="text" data-key="269"><span data-slate-leaf="true" data-offset-key="269:0" data-first-offset="true"><span class="se-7d5f047c" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Transfer-Encoding: chunked</span></span></span></span><span data-slate-object="text" data-key="270"><span data-slate-leaf="true" data-offset-key="270:0" data-first-offset="true"><span data-slate-string="true">”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。</span></span></span></div>

<div class="se-5de31e1d " data-slate-type="paragraph" data-slate-object="block" data-key="273"><span data-slate-object="text" data-key="274"><span data-slate-leaf="true" data-offset-key="274:0" data-first-offset="true"><span data-slate-string="true">分块传输也可以用于“流式数据”，例如由数据库动态生成的表单页面，这种情况下 body 数据的长度是未知的，无法在头字段“</span></span></span><span data-slate-object="text" data-key="275"><span data-slate-leaf="true" data-offset-key="275:0" data-first-offset="true"><span class="se-d647d690" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Content-Length</span></span></span></span><span data-slate-object="text" data-key="276"><span data-slate-leaf="true" data-offset-key="276:0" data-first-offset="true"><span data-slate-string="true">”里给出确切的长度，所以也只能用 chunked 方式分块发送。</span></span></span></div>

<div class="se-47d16120 " data-slate-type="paragraph" data-slate-object="block" data-key="277"><span data-slate-object="text" data-key="278"><span data-slate-leaf="true" data-offset-key="278:0" data-first-offset="true"><span data-slate-string="true">“Transfer-Encoding: chunked”和“Content-Length”这两个字段是</span></span></span><span data-slate-object="text" data-key="279"><span data-slate-leaf="true" data-offset-key="279:0" data-first-offset="true"><span class="se-44efe2ed" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">互斥的</span></span></span></span><span data-slate-object="text" data-key="280"><span data-slate-leaf="true" data-offset-key="280:0" data-first-offset="true"><span data-slate-string="true">，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked），这一点你一定要记住。</span></span></span></div>

<div class="se-af58b5a2 " data-slate-type="paragraph" data-slate-object="block" data-key="281"><span data-slate-object="text" data-key="282"><span data-slate-leaf="true" data-offset-key="282:0" data-first-offset="true"><span data-slate-string="true">下面我们来看一下分块传输的编码规则，其实也很简单，同样采用了明文的方式，很类似响应头。</span></span></span></div>

<div class="se-f3747a73" data-slate-type="list" data-slate-object="block" data-key="283"><div class="se-9523ef6e" data-slate-type="list-line" data-slate-object="block" data-key="284"><div class="se-2cc83ca7 se-bd2177e4" data-code-line-number="1"></div><div class="se-50f878b2"><span data-slate-object="text" data-key="285"><span data-slate-leaf="true" data-offset-key="285:0" data-first-offset="true"><span data-slate-string="true">每个分块包含两个部分，长度头和数据块；</span></span></span></div></div><div class="se-b1c4759c" data-slate-type="list-line" data-slate-object="block" data-key="286"><div class="se-a181cd12 se-a94d46eb" data-code-line-number="2"></div><div class="se-9b35b862"><span data-slate-object="text" data-key="287"><span data-slate-leaf="true" data-offset-key="287:0" data-first-offset="true"><span data-slate-string="true">长度头是以 CRLF（回车换行，即\r\n）结尾的一行明文，用 16 进制数字表示长度；</span></span></span></div></div><div class="se-40b9c86d" data-slate-type="list-line" data-slate-object="block" data-key="288"><div class="se-db36c629 se-c5567940" data-code-line-number="3"></div><div class="se-b86c71f5"><span data-slate-object="text" data-key="289"><span data-slate-leaf="true" data-offset-key="289:0" data-first-offset="true"><span data-slate-string="true">数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF；</span></span></span></div></div><div class="se-f2896abf" data-slate-type="list-line" data-slate-object="block" data-key="290"><div class="se-9b6e48ac se-4af0e84d" data-code-line-number="4"></div><div class="se-b9776c44"><span data-slate-object="text" data-key="291"><span data-slate-leaf="true" data-offset-key="291:0" data-first-offset="true"><span data-slate-string="true">最后用一个长度为 0 的块表示结束，即“0\r\n\r\n”。</span></span></span></div></div></div>

<div class="se-d92936bd " data-slate-type="paragraph" data-slate-object="block" data-key="292"><span data-slate-object="text" data-key="293"><span data-slate-leaf="true" data-offset-key="293:0" data-first-offset="true"><span data-slate-string="true">听起来好像有点难懂，看一下图就好理解了：</span></span></span></div>

<div class="se-2a1e5e88" data-slate-type="image" data-slate-object="block" data-key="294"><img class="se-b93c08bc" src="https://static001.geekbang.org/resource/image/25/10/25e7b09cf8cb4eaebba42b4598192410.png"></div>

<h2 class="se-c48f0612" data-slate-type="heading" data-slate-object="block" data-key="308"><span data-slate-object="text" data-key="309"><span data-slate-leaf="true" data-offset-key="309:0" data-first-offset="true"><span data-slate-string="true">范围请求</span></span></span></h2>

<div class="se-8209ffde " data-slate-type="paragraph" data-slate-object="block" data-key="310"><span data-slate-object="text" data-key="311"><span data-slate-leaf="true" data-offset-key="311:0" data-first-offset="true"><span data-slate-string="true">有了分块传输编码，服务器就可以轻松地收发大文件了，但对于上 G 的超大文件，还有一些问题需要考虑。</span></span></span></div>

<div class="se-9b86daa3 " data-slate-type="paragraph" data-slate-object="block" data-key="312"><span data-slate-object="text" data-key="313"><span data-slate-leaf="true" data-offset-key="313:0" data-first-offset="true"><span data-slate-string="true">比如，你在看当下正热播的某穿越剧，想跳过片头，直接看正片，或者有段剧情很无聊，想拖动进度条快进几分钟，这实际上是想获取一个大文件其中的片段数据，而分块传输并没有这个能力。</span></span></span></div>

<div class="se-7d3d80e6 " data-slate-type="paragraph" data-slate-object="block" data-key="314"><span data-slate-object="text" data-key="315"><span data-slate-leaf="true" data-offset-key="315:0" data-first-offset="true"><span data-slate-string="true">HTTP 协议为了满足这样的需求，提出了“</span></span></span><span data-slate-object="text" data-key="316"><span data-slate-leaf="true" data-offset-key="316:0" data-first-offset="true"><span class="se-1495fe48" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">范围请求</span></span></span></span><span data-slate-object="text" data-key="317"><span data-slate-leaf="true" data-offset-key="317:0" data-first-offset="true"><span data-slate-string="true">”（range requests）的概念，允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是</span></span></span><span data-slate-object="text" data-key="318"><span data-slate-leaf="true" data-offset-key="318:0" data-first-offset="true"><span class="se-4402ca54" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">客户端的“化整为零”</span></span></span></span><span data-slate-object="text" data-key="319"><span data-slate-leaf="true" data-offset-key="319:0" data-first-offset="true"><span data-slate-string="true">。</span></span></span></div>

<div class="se-37623716 " data-slate-type="paragraph" data-slate-object="block" data-key="320"><span data-slate-object="text" data-key="321"><span data-slate-leaf="true" data-offset-key="321:0" data-first-offset="true"><span data-slate-string="true">范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段“</span></span></span><span data-slate-object="text" data-key="322"><span data-slate-leaf="true" data-offset-key="322:0" data-first-offset="true"><span class="se-f9909507" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Accept-Ranges: bytes</span></span></span></span><span data-slate-object="text" data-key="323"><span data-slate-leaf="true" data-offset-key="323:0" data-first-offset="true"><span data-slate-string="true">”明确告知客户端：“我是支持范围请求的”。</span></span></span></div>

<div class="se-b750fd82 " data-slate-type="paragraph" data-slate-object="block" data-key="324"><span data-slate-object="text" data-key="325"><span data-slate-leaf="true" data-offset-key="325:0" data-first-offset="true"><span data-slate-string="true">如果不支持的话该怎么办呢？服务器可以发送“Accept-Ranges: none”，或者干脆不发送“Accept-Ranges”字段，这样客户端就认为服务器没有实现范围请求功能，只能老老实实地收发整块文件了。</span></span></span></div>

<div class="se-e6e06dc2 " data-slate-type="paragraph" data-slate-object="block" data-key="326"><span data-slate-object="text" data-key="327"><span data-slate-leaf="true" data-offset-key="327:0" data-first-offset="true"><span data-slate-string="true">请求头</span></span></span><span data-slate-object="text" data-key="328"><span data-slate-leaf="true" data-offset-key="328:0" data-first-offset="true"><span class="se-4b3cc2a0" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Range</span></span></span></span><span data-slate-object="text" data-key="329"><span data-slate-leaf="true" data-offset-key="329:0" data-first-offset="true"><span data-slate-string="true">是 HTTP 范围请求的专用字段，格式是“</span></span></span><span data-slate-object="text" data-key="330"><span data-slate-leaf="true" data-offset-key="330:0" data-first-offset="true"><span class="se-9fcaa2df" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">bytes=x-y</span></span></span></span><span data-slate-object="text" data-key="331"><span data-slate-leaf="true" data-offset-key="331:0" data-first-offset="true"><span data-slate-string="true">”，其中的 x 和 y 是以字节为单位的数据范围。</span></span></span></div>

<div class="se-138e27ac " data-slate-type="paragraph" data-slate-object="block" data-key="332"><span data-slate-object="text" data-key="333"><span data-slate-leaf="true" data-offset-key="333:0" data-first-offset="true"><span data-slate-string="true">要注意 x、y 表示的是“偏移量”，范围必须从 0 计数，例如前 10 个字节表示为“0-9”，第二个 10 字节表示为“10-19”，而“0-10”实际上是前 11 个字节。</span></span></span></div>

<div class="se-3b08487c " data-slate-type="paragraph" data-slate-object="block" data-key="334"><span data-slate-object="text" data-key="335"><span data-slate-leaf="true" data-offset-key="335:0" data-first-offset="true"><span data-slate-string="true">Range 的格式也很灵活，起点 x 和终点 y 可以省略，能够很方便地表示正数或者倒数的范围。假设文件是 100 个字节，那么：</span></span></span></div>

<div class="se-7e4858cf" data-slate-type="list" data-slate-object="block" data-key="336"><div class="se-86076cc8 se-cfa718e5" data-slate-type="list-line" data-slate-object="block" data-key="337"><span data-slate-object="text" data-key="338"><span data-slate-leaf="true" data-offset-key="338:0" data-first-offset="true"><span data-slate-string="true">“0-”表示从文档起点到文档终点，相当于“0-99”，即整个文件；</span></span></span></div><div class="se-84ca249e se-d3266f2f" data-slate-type="list-line" data-slate-object="block" data-key="339"><span data-slate-object="text" data-key="340"><span data-slate-leaf="true" data-offset-key="340:0" data-first-offset="true"><span data-slate-string="true">“10-”是从第 10 个字节开始到文档末尾，相当于“10-99”；</span></span></span></div><div class="se-c796ab23 se-07cf7483" data-slate-type="list-line" data-slate-object="block" data-key="341"><span data-slate-object="text" data-key="342"><span data-slate-leaf="true" data-offset-key="342:0" data-first-offset="true"><span data-slate-string="true">“-1”是文档的最后一个字节，相当于“99-99”；</span></span></span></div><div class="se-744402a6 se-b537065f" data-slate-type="list-line" data-slate-object="block" data-key="343"><span data-slate-object="text" data-key="344"><span data-slate-leaf="true" data-offset-key="344:0" data-first-offset="true"><span data-slate-string="true">“-10”是从文档末尾倒数 10 个字节，相当于“90-99”。</span></span></span></div></div>

<div class="se-911e04f7 " data-slate-type="paragraph" data-slate-object="block" data-key="345"><span data-slate-object="text" data-key="346"><span data-slate-leaf="true" data-offset-key="346:0" data-first-offset="true"><span data-slate-string="true">服务器收到 Range 字段后，需要做四件事。</span></span></span></div>

<div class="se-f72b39cf " data-slate-type="paragraph" data-slate-object="block" data-key="347"><span data-slate-object="text" data-key="348"><span data-slate-leaf="true" data-offset-key="348:0" data-first-offset="true"><span data-slate-string="true">第一，它必须检查范围是否合法，比如文件只有 100 个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码</span></span></span><span data-slate-object="text" data-key="349"><span data-slate-leaf="true" data-offset-key="349:0" data-first-offset="true"><span class="se-e7439eb9" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">416</span></span></span></span><span data-slate-object="text" data-key="350"><span data-slate-leaf="true" data-offset-key="350:0" data-first-offset="true"><span data-slate-string="true">，意思是“你的范围请求有误，我无法处理，请再检查一下”。</span></span></span></div>

<div class="se-07a915ed " data-slate-type="paragraph" data-slate-object="block" data-key="351"><span data-slate-object="text" data-key="352"><span data-slate-leaf="true" data-offset-key="352:0" data-first-offset="true"><span data-slate-string="true">第二，如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“</span></span></span><span data-slate-object="text" data-key="353"><span data-slate-leaf="true" data-offset-key="353:0" data-first-offset="true"><span class="se-5ef363cf" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">206 Partial Content</span></span></span></span><span data-slate-object="text" data-key="354"><span data-slate-leaf="true" data-offset-key="354:0" data-first-offset="true"><span data-slate-string="true">”，和 200 的意思差不多，但表示 body 只是原数据的一部分。</span></span></span></div>

<div class="se-175ea440 " data-slate-type="paragraph" data-slate-object="block" data-key="355"><span data-slate-object="text" data-key="356"><span data-slate-leaf="true" data-offset-key="356:0" data-first-offset="true"><span data-slate-string="true">第三，服务器要添加一个响应头字段</span></span></span><span data-slate-object="text" data-key="357"><span data-slate-leaf="true" data-offset-key="357:0" data-first-offset="true"><span class="se-9acc9dde" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">Content-Range</span></span></span></span><span data-slate-object="text" data-key="358"><span data-slate-leaf="true" data-offset-key="358:0" data-first-offset="true"><span data-slate-string="true">，告诉片段的实际偏移量和资源的总大小，格式是“</span></span></span><span data-slate-object="text" data-key="359"><span data-slate-leaf="true" data-offset-key="359:0" data-first-offset="true"><span class="se-0246d91d" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">bytes x-y/length</span></span></span></span><span data-slate-object="text" data-key="360"><span data-slate-leaf="true" data-offset-key="360:0" data-first-offset="true"><span data-slate-string="true">”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。</span></span></span></div>

<div class="se-c96e6b8f " data-slate-type="paragraph" data-slate-object="block" data-key="365"><span data-slate-object="text" data-key="366"><span data-slate-leaf="true" data-offset-key="366:0" data-first-offset="true"><span data-slate-string="true">例如下面的这个请求使用 Range 字段获取了文件的前 32 个字节：</span></span></span></div>

<div class="se-8698fab3 se-0912d0f0" data-slate-type="pre" data-slate-object="block" data-key="367"><div class="se-2350d97f se-6ce270c1"><span></span></div><div class="se-f7e31597"><div class="se-12376ff1 se-21f523b8" data-code-line-number="1"></div><div class="se-12376ff1 se-21f523b8" data-code-line-number="2"></div><div class="se-12376ff1 se-21f523b8" data-code-line-number="3"></div></div><div class="se-4bc3b0e3 ps"><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="368"><span data-slate-object="text" data-key="369"><span data-slate-leaf="true" data-offset-key="369:0" data-first-offset="true"><span data-slate-string="true">GET /16-2 HTTP/1.1</span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="370"><span data-slate-object="text" data-key="371"><span data-slate-leaf="true" data-offset-key="371:0" data-first-offset="true"><span data-slate-string="true">Host: www.chrono.com</span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="372"><span data-slate-object="text" data-key="373"><span data-slate-leaf="true" data-offset-key="373:0" data-first-offset="true"><span data-slate-string="true">Range: bytes=0-31</span></span></span></div><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></div>

<div class="se-5ee9f0e6 " data-slate-type="paragraph" data-slate-object="block" data-key="374"><span data-slate-object="text" data-key="375"><span data-slate-leaf="true" data-offset-key="375:0" data-first-offset="true"><span data-slate-string="true">返回的数据是（去掉了几个无关字段）：</span></span></span></div>

<div class="se-707a13fc se-65732716" data-slate-type="pre" data-slate-object="block" data-key="376" data-code-language="javascript"><div class="se-99d37a6a se-b4063707"><span></span></div><div class="se-bbbbebce"><div class="se-7ead5f01 se-4ab95b8e" data-code-line-number="1"></div><div class="se-7ead5f01 se-4ab95b8e" data-code-line-number="2"></div><div class="se-7ead5f01 se-4ab95b8e" data-code-line-number="3"></div><div class="se-7ead5f01 se-4ab95b8e" data-code-line-number="4"></div><div class="se-7ead5f01 se-4ab95b8e" data-code-line-number="5"></div><div class="se-7ead5f01 se-4ab95b8e" data-code-line-number="6"></div></div><div class="se-4c900e44 ps"><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="377"><span data-slate-object="text" data-key="378"><span data-slate-leaf="true" data-offset-key="378:0" data-first-offset="true"><span data-slate-string="true">HTTP/</span></span><span data-slate-leaf="true" data-offset-key="378:1"><span class=" gkhl-number" data-slate-object="annotation" data-annotation-key="gkann_7481658487" data-annotation-type="annotation"><span data-slate-string="true">1.1</span></span></span><span data-slate-leaf="true" data-offset-key="378:2"><span data-slate-string="true"> </span></span><span data-slate-leaf="true" data-offset-key="378:3"><span class=" gkhl-number" data-slate-object="annotation" data-annotation-key="gkann_5794568717" data-annotation-type="annotation"><span data-slate-string="true">206</span></span></span><span data-slate-leaf="true" data-offset-key="378:4"><span data-slate-string="true"> Partial Content</span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="379"><span data-slate-object="text" data-key="380"><span data-slate-leaf="true" data-offset-key="380:0" data-first-offset="true"><span data-slate-string="true">Content-Length: </span></span><span data-slate-leaf="true" data-offset-key="380:1"><span class=" gkhl-number" data-slate-object="annotation" data-annotation-key="gkann_5423843418" data-annotation-type="annotation"><span data-slate-string="true">32</span></span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="381"><span data-slate-object="text" data-key="382"><span data-slate-leaf="true" data-offset-key="382:0" data-first-offset="true"><span data-slate-string="true">Accept-Ranges: bytes</span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="383"><span data-slate-object="text" data-key="384"><span data-slate-leaf="true" data-offset-key="384:0" data-first-offset="true"><span data-slate-string="true">Content-Range: bytes </span></span><span data-slate-leaf="true" data-offset-key="384:1"><span class=" gkhl-number" data-slate-object="annotation" data-annotation-key="gkann_9797059168" data-annotation-type="annotation"><span data-slate-string="true">0</span></span></span><span data-slate-leaf="true" data-offset-key="384:2"><span class=" gkhl-number" data-slate-object="annotation" data-annotation-key="gkann_4761191652" data-annotation-type="annotation"><span data-slate-string="true">-31</span></span></span><span data-slate-leaf="true" data-offset-key="384:3"><span data-slate-string="true">/</span></span><span data-slate-leaf="true" data-offset-key="384:4"><span class=" gkhl-number" data-slate-object="annotation" data-annotation-key="gkann_8106110452" data-annotation-type="annotation"><span data-slate-string="true">96</span></span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="385"><span data-slate-object="text" data-key="386"></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="387"><span data-slate-object="text" data-key="388"><span data-slate-leaf="true" data-offset-key="388:0" data-first-offset="true"><span class=" gkhl-comment" data-slate-object="annotation" data-annotation-key="gkann_2947545037" data-annotation-type="annotation"><span data-slate-string="true">// this is a plain text json doc</span></span></span></span></div><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></div>

<div class="se-5350215c " data-slate-type="paragraph" data-slate-object="block" data-key="389"><span data-slate-object="text" data-key="390"><span data-slate-leaf="true" data-offset-key="390:0" data-first-offset="true"><span data-slate-string="true">有了范围请求之后，HTTP 处理大文件就更加轻松了，看视频时可以根据时间点计算出文件的 Range，不用下载整个文件，直接精确获取片段所在的数据内容。</span></span></span></div>

<div class="se-1636b83e " data-slate-type="paragraph" data-slate-object="block" data-key="391"><span data-slate-object="text" data-key="392"><span data-slate-leaf="true" data-offset-key="392:0" data-first-offset="true"><span data-slate-string="true">不仅看视频的拖拽进度需要范围请求，常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：</span></span></span></div>

<div class="se-904fb80a" data-slate-type="list" data-slate-object="block" data-key="393"><div class="se-36809dc9 se-1e99b8ed" data-slate-type="list-line" data-slate-object="block" data-key="394"><span data-slate-object="text" data-key="395"><span data-slate-leaf="true" data-offset-key="395:0" data-first-offset="true"><span data-slate-string="true">先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；</span></span></span></div><div class="se-d29b1721 se-21638a19" data-slate-type="list-line" data-slate-object="block" data-key="396"><span data-slate-object="text" data-key="397"><span data-slate-leaf="true" data-offset-key="397:0" data-first-offset="true"><span data-slate-string="true">开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；</span></span></span></div><div class="se-65ba8714 se-929ea35d" data-slate-type="list-line" data-slate-object="block" data-key="398"><span data-slate-object="text" data-key="399"><span data-slate-leaf="true" data-offset-key="399:0" data-first-offset="true"><span data-slate-string="true">下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。</span></span></span></div></div>

<h2 class="se-e71bf067" data-slate-type="heading" data-slate-object="block" data-key="400"><span data-slate-object="text" data-key="401"><span data-slate-leaf="true" data-offset-key="401:0" data-first-offset="true"><span data-slate-string="true">多段数据</span></span></span></h2>

<div class="se-5975654e " data-slate-type="paragraph" data-slate-object="block" data-key="402"><span data-slate-object="text" data-key="403"><span data-slate-leaf="true" data-offset-key="403:0" data-first-offset="true"><span data-slate-string="true">刚才说的范围请求一次只获取一个片段，其实它还支持在 Range 头里使用多个“x-y”，一次性获取多个片段数据。</span></span></span></div>

<div class="se-5d10638c " data-slate-type="paragraph" data-slate-object="block" data-key="404"><span data-slate-object="text" data-key="405"><span data-slate-leaf="true" data-offset-key="405:0" data-first-offset="true"><span data-slate-string="true">这种情况需要使用一种特殊的 MIME 类型：“</span></span></span><span data-slate-object="text" data-key="406"><span data-slate-leaf="true" data-offset-key="406:0" data-first-offset="true"><span class="se-de186147" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">multipart/byteranges</span></span></span></span><span data-slate-object="text" data-key="407"><span data-slate-leaf="true" data-offset-key="407:0" data-first-offset="true"><span data-slate-string="true">”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“</span></span></span><span data-slate-object="text" data-key="408"><span data-slate-leaf="true" data-offset-key="408:0" data-first-offset="true"><span class="se-f012b002" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">boundary=xxx</span></span></span></span><span data-slate-object="text" data-key="409"><span data-slate-leaf="true" data-offset-key="409:0" data-first-offset="true"><span data-slate-string="true">”给出段之间的分隔标记。</span></span></span></div>

<div class="se-e0cfbc45 " data-slate-type="paragraph" data-slate-object="block" data-key="410"><span data-slate-object="text" data-key="411"><span data-slate-leaf="true" data-offset-key="411:0" data-first-offset="true"><span data-slate-string="true">多段数据的格式与分块传输也比较类似，但它需要用分隔标记 boundary 来区分不同的片段，可以通过图来对比一下。</span></span></span></div>

<div class="se-c0227c09" data-slate-type="image" data-slate-object="block" data-key="412"><img class="se-709da73c" src="https://static001.geekbang.org/resource/image/ff/37/fffa3a65e367c496428f3c0c4dac8a37.png"></div>

<div class="se-3058c874 " data-slate-type="paragraph" data-slate-object="block" data-key="413"><span data-slate-object="text" data-key="414"><span data-slate-leaf="true" data-offset-key="414:0" data-first-offset="true"><span data-slate-string="true">每一个分段必须以“- -boundary”开始（前面加两个“-”），之后要用“Content-Type”和“Content-Range”标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个“- -boundary- -”（前后各有两个“-”）表示所有的分段结束。</span></span></span></div>

<div class="se-7e8bec9f " data-slate-type="paragraph" data-slate-object="block" data-key="415"><span data-slate-object="text" data-key="416"><span data-slate-leaf="true" data-offset-key="416:0" data-first-offset="true"><span data-slate-string="true">例如，我们在实验环境里用 Telnet 发出有两个范围的请求：</span></span></span></div>

<div class="se-8f6b8593 se-7327677e" data-slate-type="pre" data-slate-object="block" data-key="417"><div class="se-50b3c941 se-1e8b0469"><span></span></div><div class="se-ac63dfd4"><div class="se-b3f51b15 se-a8a7f4fc" data-code-line-number="1"></div><div class="se-b3f51b15 se-a8a7f4fc" data-code-line-number="2"></div><div class="se-b3f51b15 se-a8a7f4fc" data-code-line-number="3"></div></div><div class="se-88945cda ps"><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="418"><span data-slate-object="text" data-key="419"><span data-slate-leaf="true" data-offset-key="419:0" data-first-offset="true"><span data-slate-string="true">GET /16-2 HTTP/1.1</span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="420"><span data-slate-object="text" data-key="421"><span data-slate-leaf="true" data-offset-key="421:0" data-first-offset="true"><span data-slate-string="true">Host: www.chrono.com</span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="422"><span data-slate-object="text" data-key="423"><span data-slate-leaf="true" data-offset-key="423:0" data-first-offset="true"><span data-slate-string="true">Range: bytes=0-9, 20-29</span></span></span></div><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></div>

<div class="se-9833342f " data-slate-type="paragraph" data-slate-object="block" data-key="424"><span data-slate-object="text" data-key="425"><span data-slate-leaf="true" data-offset-key="425:0" data-first-offset="true"><span data-slate-string="true">得到的就会是下面这样：</span></span></span></div>

<div class="se-b6cb33fd se-cb3e7e33" data-slate-type="pre" data-slate-object="block" data-key="426" data-code-language="sql"><div class="se-c88cd0a0 se-25f6dd82"><span></span></div><div class="se-2eebf819"><div class="se-707d200f se-46fb3b23" data-code-line-number="1"></div><div class="se-707d200f se-46fb3b23" data-code-line-number="2"></div><div class="se-707d200f se-46fb3b23" data-code-line-number="3"></div><div class="se-707d200f se-46fb3b23" data-code-line-number="4"></div><div class="se-707d200f se-46fb3b23" data-code-line-number="5"></div><div class="se-707d200f se-46fb3b23" data-code-line-number="6"></div><div class="se-707d200f se-46fb3b23" data-code-line-number="7"></div><div class="se-707d200f se-46fb3b23" data-code-line-number="8"></div><div class="se-707d200f se-46fb3b23" data-code-line-number="9"></div><div class="se-707d200f se-46fb3b23" data-code-line-number="10"></div><div class="se-707d200f se-46fb3b23" data-code-line-number="11"></div><div class="se-707d200f se-46fb3b23" data-code-line-number="12"></div><div class="se-707d200f se-46fb3b23" data-code-line-number="13"></div><div class="se-707d200f se-46fb3b23" data-code-line-number="14"></div><div class="se-707d200f se-46fb3b23" data-code-line-number="15"></div><div class="se-707d200f se-46fb3b23" data-code-line-number="16"></div><div class="se-707d200f se-46fb3b23" data-code-line-number="17"></div><div class="se-707d200f se-46fb3b23" data-code-line-number="18"></div></div><div class="se-c3d9c665 ps"><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="427"><span data-slate-object="text" data-key="428"><span data-slate-leaf="true" data-offset-key="428:0" data-first-offset="true"><span data-slate-string="true">HTTP/1.1 206 Partial Content</span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="429"><span data-slate-object="text" data-key="430"><span data-slate-leaf="true" data-offset-key="430:0" data-first-offset="true"><span data-slate-string="true">Content-Type: multipart/byteranges; boundary=00000000001</span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="431"><span data-slate-object="text" data-key="432"><span data-slate-leaf="true" data-offset-key="432:0" data-first-offset="true"><span data-slate-string="true">Content-Length: 189</span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="433"><span data-slate-object="text" data-key="434"><span data-slate-leaf="true" data-offset-key="434:0" data-first-offset="true"><span data-slate-string="true">Connection: keep-alive</span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="435"><span data-slate-object="text" data-key="436"><span data-slate-leaf="true" data-offset-key="436:0" data-first-offset="true"><span data-slate-string="true">Accept-Ranges: bytes</span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="437"><span data-slate-object="text" data-key="438"></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="439"><span data-slate-object="text" data-key="440"></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="441"><span data-slate-object="text" data-key="442"><span data-slate-leaf="true" data-offset-key="442:0" data-first-offset="true"><span class=" gkhl-comment" data-slate-object="annotation" data-annotation-key="gkann_0027017017" data-annotation-type="annotation"><span data-slate-string="true">--00000000001</span></span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="443"><span data-slate-object="text" data-key="444"><span data-slate-leaf="true" data-offset-key="444:0" data-first-offset="true"><span data-slate-string="true">Content-Type: text/plain</span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="445"><span data-slate-object="text" data-key="446"><span data-slate-leaf="true" data-offset-key="446:0" data-first-offset="true"><span data-slate-string="true">Content-Range: bytes 0-9/96</span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="447"><span data-slate-object="text" data-key="448"></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="449"><span data-slate-object="text" data-key="450"><span data-slate-leaf="true" data-offset-key="450:0" data-first-offset="true"><span data-slate-string="true">// this is</span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="451"><span data-slate-object="text" data-key="452"><span data-slate-leaf="true" data-offset-key="452:0" data-first-offset="true"><span class=" gkhl-comment" data-slate-object="annotation" data-annotation-key="gkann_0955036076" data-annotation-type="annotation"><span data-slate-string="true">--00000000001</span></span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="453"><span data-slate-object="text" data-key="454"><span data-slate-leaf="true" data-offset-key="454:0" data-first-offset="true"><span data-slate-string="true">Content-Type: text/plain</span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="455"><span data-slate-object="text" data-key="456"><span data-slate-leaf="true" data-offset-key="456:0" data-first-offset="true"><span data-slate-string="true">Content-Range: bytes 20-29/96</span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="457"><span data-slate-object="text" data-key="458"></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="459"><span data-slate-object="text" data-key="460"><span data-slate-leaf="true" data-offset-key="460:0" data-first-offset="true"><span data-slate-string="true">ext json d</span></span></span></div><div class="se-be502ea8 se-67df5c0b" data-slate-type="code-line" data-slate-object="block" data-key="461"><span data-slate-object="text" data-key="462"><span data-slate-leaf="true" data-offset-key="462:0" data-first-offset="true"><span class=" gkhl-comment" data-slate-object="annotation" data-annotation-key="gkann_9268188427" data-annotation-type="annotation"><span data-slate-string="true">--00000000001--</span></span></span></span></div><div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></div></div>

<div class="se-b91ca6d2 " data-slate-type="paragraph" data-slate-object="block" data-key="237"><span data-slate-object="text" data-key="238"><span data-slate-leaf="true" data-offset-key="238:0" data-first-offset="true"><span data-slate-string="true">报文里的“- -00000000001”就是多段的分隔符，使用它客户端就可以很容易地区分出多段 Range 数据。</span></span></span></div>

<div class="se-7b1d56d3" data-slate-type="list" data-slate-object="block" data-key="243"><div class="se-62ea0f70" data-slate-type="list-line" data-slate-object="block" data-key="244"><div class="se-20ac70bb se-b670f1b9" data-code-line-number="1"></div><div class="se-24d6e7e3"><span data-slate-object="text" data-key="245"><span data-slate-leaf="true" data-offset-key="245:0" data-first-offset="true"><span class="se-704b70d9" data-slate-type="primary" data-slate-object="mark"><span data-slate-string="true">压缩 HTML 等文本文件是传输大文件最基本的方法；</span></span></span></span></div></div><div class="se-2740f414" data-slate-type="list-line" data-slate-object="block" data-key="246"><div class="se-3aa1d7f9 se-282a11a4" data-code-line-number="2"></div><div class="se-29ac98fc"><span data-slate-object="text" data-key="247"><span data-slate-leaf="true" data-offset-key="247:0" data-first-offset="true"><span class="se-704b70d9" data-slate-type="primary" data-slate-object="mark"><span data-slate-string="true">分块传输可以流式收发数据，节约内存和带宽，使用响应头字段“Transfer-Encoding: chunked”来表示，分块的格式是 16 进制长度头 + 数据块；</span></span></span></span></div></div><div class="se-4722a07b" data-slate-type="list-line" data-slate-object="block" data-key="248"><div class="se-b0945db6 se-461273b6" data-code-line-number="3"></div><div class="se-eefddc36"><span data-slate-object="text" data-key="249"><span data-slate-leaf="true" data-offset-key="249:0" data-first-offset="true"><span class="se-704b70d9" data-slate-type="primary" data-slate-object="mark"><span data-slate-string="true">范围请求可以只获取部分数据，即“分块请求”，实现视频拖拽或者断点续传，使用请求头字段“Range”和响应头字段“Content-Range”，响应状态码必须是 206；</span></span></span></span></div></div><div class="se-2c0e11fc" data-slate-type="list-line" data-slate-object="block" data-key="250"><div class="se-67d791c0 se-2e661e3d" data-code-line-number="4"></div><div class="se-49d9d2d2"><span data-slate-object="text" data-key="251"><span data-slate-leaf="true" data-offset-key="251:0" data-first-offset="true"><span class="se-704b70d9" data-slate-type="primary" data-slate-object="mark"><span data-slate-string="true">也可以一次请求多个范围，这时候响应报文的数据类型是“multipart/byteranges”，body 里的多个部分会用 boundary 字符串分隔。</span></span></span></span></div></div></div>















